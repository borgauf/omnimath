<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-04 Fri 11:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="./tufte.css" type="text/css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<div class="header">
<link rel="stylesheet" href="hamb.css">
<link rel="stylesheet" href="tufte.css">
<img src="./images/heading6.png"  style="padding: 0px 0px 22px 0px" alt="3-d graph" class="center">

<p>

<nav role="navigation">
  <div id="menuToggle">
    <!--
    A fake / hidden checkbox is used as click reciever,
    so you can use the :checked selector on it.
    -->
    <input type="checkbox" />
    
    <!--
    Some spans to act as a hamburger.
    
    They are acting like a real hamburger,
    not that McDonalds stuff.
    -->
    <span></span>
    <span></span>
    <span></span>
    
    <!--
    Too bad the menu has to be inside of the button
    but hey, it's pure CSS magic.
    -->
    <ul id="menu">
      <a href="index.html" target="_blank"><li>Home</li></a>
      <a href="preface.html" target="_blank"><li>Preface</li></a>
      <a href="preliminaries.html" target="_blank"><li>Rabbit Holes</li></a>
      <li>Numbers</li>
      <ul>
         <a href="numbers1.html" target="_blank"><li>Numbers 1</li></a>
         <a href="numbers2.html" target="_blank"><li>Numbers 2</li></a>
      </ul>
    </ul>
  </div>
</nav>
</div>
</p>

<div id="outline-container-orgaee9956" class="outline-2">
<h2 id="orgaee9956">Numbers</h2>
</div>


<div id="outline-container-orgd8d0d64" class="outline-2">
<h2 id="orgd8d0d64">Introduction to part 2</h2>
<div class="outline-text-2" id="text-orgd8d0d64">
<p>
We&rsquo;ll pick up where we left off with our breakdown of the three basic
<i>qualities of quantities</i><label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
If you&rsquo;re jumping in here make sure you reload <code>numbers1.hs</code>,
along with <code>numbers2.hs</code> from this section&rsquo;s work.
</span>
</p>

<ul class="org-ul">
<li>cardinality, or <i>how many?</i></li>
<li>ordinality, or <i>what order?</i></li>
<li>enumeration, or, generally, <i>how do we count out things?</i></li>
</ul>

<p>
In this section we&rsquo;ll tackle enumeration.
</p>

<p>
To be sure, <i>enumeration</i>, or as it is also called <i>combinatorics</i>, is
a huge and active field of mathematics, parts of which are included in
introductions to Discrete Mathematics, and in general, are fair game
throughout a CS degree. This means our approach with CIMIC will have
to be rather pruned and directed, since the combinatorics tree is big
and bushy.
</p>

<p>
Truth be told, the first time you hear about enumeration as a
beginning Haskeller isn&rsquo;t really about all this deep, bushy math,
rather doing things like completing a <i>range</i><label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
Make sure you&rsquo;ve seen <a href="http://learnyouahaskell.com/starting-out#texas-ranges">Texas ranges</a> in LYAHFGG.
</span>, e.g.
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>12<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,2,3,4,5,6,7,8,9,10,11,12]
</pre>


<p>
or<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
In this next example we use the open-ended &ldquo;infinite&rdquo; list &#x2014;
which will typically go on forever, locking up your computer as it
tries to list <i>all</i> of numbers, or in this case letters. We use the
function <code>take</code> to take just the first <code>27</code> letters and not go any
further. Curiously, Haskell thinks the twenty-seventh letter is
<code>{</code>. That&rsquo;s because these are <i>unicode</i> characters, of which there are
some 1,114,015, according to Haskell. It&rsquo;s usually safe to use an
infinite list with preface functions <br />
<code>Î»&gt; length ['a'..]</code> <br />
<code>1114015</code>
</span>
</p>

<pre class="code"><code><span class="org-haskell-definition">take</span> 27 <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'a'</span><span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
abcdefghijklmnopqrstuvwxyz{
</pre>


<p>
This is a tool of Haskell&rsquo;s that allows us to &ldquo;enumerate&rdquo; (fill in) a
pattern of list elements. And it should be no surprise that Haskell
has a type class, <code>Enum</code> to which types can register instances. <code>Enum</code>
has special method functions which create this behavior, this
enumeration-ness, for a data type. But before we talk about <code>Enum</code>,
let&rsquo;s work with the more discrete math side of things.
</p>
</div>


<div id="outline-container-org50a7766" class="outline-3">
<h3 id="org50a7766">Enumeration is enumerating, counting, listing out&#x2026;</h3>
<div class="outline-text-3" id="text-org50a7766">
<p>
&#x2026;completing a numerical layout given certain conditions perhaps?
It&rsquo;s a bit difficult to describe what enumeration is. To count
something might seem like a dynamic process. We take objects out of a
box and <i>count</i> how many there are &#x2014; with each object increasing the
<a href="https://www.dictionary.com/browse/augend">augend</a>, the final augend being the answer. In simple language this is
finding a sum. But what if finding, e.g., a sum isn&rsquo;t as simple as
just grabbing one after another out of a box? What if the grabbing
<i>and</i> the displaying, arranging, stacking on the table is complex and
involved? There are many situations that have very deep, very complex
grabbing, and arranging processes.
</p>

<p>
The simplest way to display a set is to literally list out each
element one by one. This is considered enumeration as well. Then
there&rsquo;s the use of <i><font color = "#650d1c" size =
5%>ellipses (&#x2026;)</font></i> to indicate we want elements
&ldquo;filled out&rdquo; according to some scheme we&rsquo;re following. But here we
encounter LE issues, ambiguities. For example \(\{1,2,3,\ldots\}\;\)
could mean a listing of the counting numbers, or it might indicate the
<a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a> where each new number (beyond the first two) is the
previous two added together, i.e.,
\(\{1,2,3,5,8,13\ldots\}\;\;\)<label for="4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="4" class="margin-toggle"/><span class="sidenote">
We&rsquo;ll take apart how Haskell&rsquo;s enumeration-ness class <code>Enum</code>
handles ranges just up ahead.
</span>.
</p>
</div>
</div>
</div>

<div id="outline-container-org9b4f2d4" class="outline-2">
<h2 id="org9b4f2d4">Natural numbers</h2>
<div class="outline-text-2" id="text-org9b4f2d4">
<p>
Sometime long ago somebody wondered, If I have something like a big
number &#x2014; the biggest I can possibly imagine &#x2014; doesn&rsquo;t adding \(1\)
to that number result in a new biggest number? And in general, can&rsquo;t
we say that starting from nothing, adding one more gets the <i>next</i>
number? There&rsquo;s no Haskell <code>Next</code> class that we know of, but next-ness
is a curious beast indeed.
</p>
</div>

<div id="outline-container-org5052b66" class="outline-3">
<h3 id="org5052b66">The natural, whole, positive, counting numbers<label for="5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="5" class="margin-toggle"/><span class="sidenote">
&#x2026;with no bigodd nonsense about them &#x2014; a phrase used
repeatedly by the character ironically called Sparkler in Charles
Dickens&rsquo; <i>Little Dorrit</i>.
</span></h3>
<div class="outline-text-3" id="text-org5052b66">
<p>
Taking a stab at a word definition of the natural counting numbers,
\(\mathbb{N}\), in a quasi-set notation style
</p>

\begin{align*}
\mathbb{N} = \{all\; the\; whole\; numbers\; starting\; with\; zero\}
\end{align*}

<p>
But what do we mean by <i>all</i> and <i>starting with</i>? And what about
order? Or are these whole numbers just in whatever order as long
as they&rsquo;re <i>after</i> zero? Of course our intuitive understanding of what
counting numbers are saves us from silly hypothetical questions like
this, right?
</p>
</div>
</div>

<div id="outline-container-orge46d223" class="outline-3">
<h3 id="orge46d223">Peano&rsquo;s approach to the natural numbers</h3>
<div class="outline-text-3" id="text-orge46d223">
<p>
The latter half of the nineteenth century saw mathematics going
through an intense effort to expand and deepen mathematical formalism
and exactness. Mathematicians wanted to firm up math&rsquo;s logical
underpinnings, clean up sloppy, intuitive, hand-waving
half-understandings and put things on solid, unassailable logical
footing. One such mathematician was <a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a>.
</p>

<p>
Logical soul-searching led Peano to ask what exactly were the counting
numbers after all? Sure, there&rsquo;s the Kindergarten version of
\(\mathbb{N}\;\), but was there something set-theoretic foundational
underneath just rattling off numbers like a child? After all, that&rsquo;s
not much different from circus animals learning tricks.
</p>

<p>
Let&rsquo;s warm up by considering what we said in the last section about
\(3\) being what comes after \(2\), which in turn comes after \(1\;\). In
effect, one number <i>succeeds</i> another. And so, in theory at least, we
could start at \(0\;\) and literally build a chain of <i>succeeds</i> up
to any number we want. This is like saying every journey starts with a
first step, followed by the next step, then the next, etc. Yes, this
may seen trivial, silly, but there&rsquo;s a lot of math packed in this
concept.
</p>
</div>

<div id="outline-container-org422f4a7" class="outline-4">
<h4 id="org422f4a7">A first stab at a formalization</h4>
<div class="outline-text-4" id="text-org422f4a7">
<p>
Later we&rsquo;ll go into a more detail about what a function is
set-theoretically, but to get started that brutalist interpretation of
functions you learned sometime after Kindergarten will do. So let&rsquo;s
have the idea of one thing succeeding another housed in a <i>successor
function</i> \(S(n)\;\). And yet we won&rsquo;t say something like
</p>

\begin{align*}
S(n) = n + 1
\end{align*}

<p>
because that would be too, well, brutalist. 
</p>

<p>
For example, if we start at \(0\), the successor to \(0\) is \(1\;\), or
\(S(0) = 1\;\). But if we&rsquo;re going to be highly abstract and pure about
this, we don&rsquo;t want or need to connect this to any actual numerical
symbols of base\(_{10}\) like \(1\;\). So we&rsquo;ll just use the usual numerical
symbols as reminders. Let&rsquo;s  So in order to Instead, we&rsquo;ll just keep
reapplying the successor function \(S\;\) similar to nesting Russian
dolls<label for="6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="6" class="margin-toggle"/><span class="sidenote">
Russian or <i>matryoshka</i> dolls: <br />
<img src="images/russiandolls.png" alt="russiandolls.png" />  <br />
<br />
</span>
</p>

\begin{align*}
0 &= 0 \\
1 &= S(0) \\
2 &= S(S(0)) \\
3 &= S(S(S(0))) \\
4 &= S(S(S(S(0)))) \\
\ldots
\end{align*}

<p>
Awkward? YMMV<label for="7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="7" class="margin-toggle"/><span class="sidenote">
Your mileage may vary. 
</span>. But we have to admit we&rsquo;ve defined something akin
to the natural numbers using just the constant \(0\) and a successor
function applied to it. Now, let&rsquo;s define addition on this system. To
do this we&rsquo;ll use these two <i>identities</i>
</p>

\begin{align}
x + 0 &= x \\
x + s(y) &= s(x + y)
\end{align}

<p>
This should cover all possible cases of addition. Testing, let&rsquo;s add
\(1\) and \(2\;\) or \(s(0) + s(s(0))\;\)
</p>

\begin{align}
s(0) + s(s(0)) &= \\
s(s(0) + s(0)) &= \\
s(s(s(0)) + 0) &= s(s(s(0)))
\end{align}

<ul class="org-ul">
<li>We apply (2) to (3) to get (4); in effect abstracting \(1+2\;\), the
left side of (2), to the <i>successor</i> of \(1+1\;\), the right side of
(2).</li>
<li>But now the inner part of (4), namely \(s(0) + s(0)\;\), resembles (2)
allowing us to match the first \(s(0)\) to \(x\) and the second to
\(s(y)\), which in turn allows us to rewrite it as \(s(s(0) +
  0)\;\).</li>
<li>But according to (1) \(s(0) + 0 = s(0)\;\;\), leaving \(s(s(0))\;\)</li>
<li>Including back in the outermost \(s\) we now have \(s(s(s(0)))\;\) our
answer.</li>
</ul>


<p>
What have we accomplished with this convoluted method? For one, we&rsquo;ve
reduced the entire idea of the natural numbers, along with adding two
of these reimagined natural numbers, to just a small set of symbols,
namely
</p>

<ul class="org-ul">
<li>a <i>constant</i> symbol \(0\)</li>
<li>variable symbols \(x\) and \(y\)</li>
<li>and a function symbol \(s\)</li>
</ul>

<p>
And with these four symbols we create statements made of <i>terms</i> built
from our symbols as in (1) and (2), e.g., \(x + 0\;\) is term, and
\(s(x + y)\;\) is another term. This allows us to state our problem as
terms, then <i>rewrite</i> these terms step-by-step as we did above to get
to a final term rewrite that is our answer. And so we have a <i>term
rewriting system</i> that provides addition of our natural
numbers<label for="8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="8" class="margin-toggle"/><span class="sidenote">
Rewriting is basically what you do when you, e.g., take steps
to simplify or reduce a fraction. More on normal or canonical forms
later.
</span>. As Madhavan Mukund says<label for="9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="9" class="margin-toggle"/><span class="sidenote">
<a href="https://www.cmi.ac.in/~madhavan/papers/pdf/programming-language-concepts.pdf">Mukund lecture notes</a>. 
</span> 
</p>

<div class="epigraph"><blockquote>
<p>
In a sense, rewriting is at the heart of all formulations of
computability &#x2014; any computational device&rsquo;s fundamental behaviour is
to read symbols and generate other symbols, which amounts to rewriting
the input as the output.
</p>

</blockquote></div>

<p>
So what&rsquo;s the alternative? Your modern digital computer creates a
human-friendly world of numbers and addition with the help of base\(_{2}\)
binary numbers, computer circuit board logic gates, and lots and lots
of Assembler code to manage it all. Then come the higher languages
which present math as we normally see it, e.g., \(1 + 1 = 2\;\). When
seen in this light, we might begin to appreciate a very basic,
fundamental fact about modern computing, namely, <font color =
"#4715b3">we can create strategies to accomplish logical
calculations by manipulating (rewriting) <i>terms</i> built of
<i>symbols</i>.</font> Again, this adds a whole new dimension to
our age-old math world mix of scrolls, paper, books, pencils,
blackboards and chalk, and those mysterious mental representations of
math inside our human brains.
</p>
</div>
</div>

<div id="outline-container-org23d5bf0" class="outline-4">
<h4 id="org23d5bf0">A first look at induction and recursion<label for="10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="10" class="margin-toggle"/><span class="sidenote">
At this point we can say induction and recursion (and
recurrence relations in general) are just two sides of the same
coin. Make sure you&rsquo;ve got this <a href="http://learnyouahaskell.com/recursion">LYAHFGG&rsquo;s Recursion</a> chapter under your
belt.
</span></h4>
<div class="outline-text-4" id="text-org23d5bf0">
<img src="./images/fallingdominoes.png" width="725px" style="padding: 15px 0px 0px 0px" alt="Induction example: dominoes falling" class="center">
<span class="cap">Example of induction: if one domino falls, so will the next.</span>

<p>
Simplistic as our natural number system in the previous section may
seem, there&rsquo;s actually quite a bit of math theory to unpack to really
understand what just happened. When we build a number up from repeated
or nested application of the successor function \(s\) we were using the
ideas of <i>induction</i> and <i>recursion</i><label for="11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="11" class="margin-toggle"/><span class="sidenote">
You may or may not have encountered induction. Typically, a
math course will introduce it as a proof strategy.
</span>.
</p>

<p>
Again, this may seem very simplistic, but the idea of induction is
inherent to the natural numbers. So if \(\mathbb{N}\;\) is also referred
to as the counting numbers, then we count or <i>enumerate</i> things with
them&#x2014;going up as high as we need to
</p>

<table id="org4eb7195" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Enumeration of the first ten primes</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
<td class="org-right">11</td>
<td class="org-right">13</td>
<td class="org-right">17</td>
<td class="org-right">19</td>
<td class="org-right">23</td>
<td class="org-right">29</td>
</tr>
</tbody>
</table>

<p>
Let&rsquo;s make a quick look-up table in Haskell for Table 1
</p>

<pre class="code"><code>
<span class="org-haskell-definition">primeEnum</span> n <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">&lt;</span> 11<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">&gt;</span> 0<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> <span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">of</span>
                          1  <span class="org-haskell-operator">-&gt;</span> 2
                          2  <span class="org-haskell-operator">-&gt;</span> 3
                          3  <span class="org-haskell-operator">-&gt;</span> 5
                          4  <span class="org-haskell-operator">-&gt;</span> 7
                          5  <span class="org-haskell-operator">-&gt;</span> 11
                          6  <span class="org-haskell-operator">-&gt;</span> 13
                          7  <span class="org-haskell-operator">-&gt;</span> 17
                          8  <span class="org-haskell-operator">-&gt;</span> 19
                          9  <span class="org-haskell-operator">-&gt;</span> 23
                          10 <span class="org-haskell-operator">-&gt;</span> 29
            <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> error <span class="org-string">"We only know the first ten primes."</span>
            
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">primeEnum</span> 9
</code></pre>

<pre class="example">
23
</pre>


<p>
Mathematicians abstracted &ldquo;the next one&rdquo; by saying for any \(n \in
\mathbb{N}\;\), there will be a \(n+1 \in \mathbb{N}\;\;\) &ldquo;next one after
\(n\;\)&rdquo;. Myriad phenomena in life and math lend themselves to this
&ldquo;if you&rsquo;ve got this one, you can get next one&rdquo; idea.
</p>

<p>
ðð­<label for="12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="12" class="margin-toggle"/><span class="sidenote">
<b>zB</b>: German abbreviation for <i>zum Beispiel</i>, or for example.
</span>: A classic proof using mathematical induction is the
proposition<label for="13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="13" class="margin-toggle"/><span class="sidenote">
Propositions are statements or assertions that can be proven
to be either true or false. Make sure you went down <a href="https://math.libretexts.org/Courses/Monroe_Community_College/MTH_220_Discrete_Math/2%3A_Logic/2.1%3A_Propositions">this rabbit hole</a>.
</span>
</p>

\begin{align*}
P(n) = 0 + 1 + 2 + 3 + \ldots + n = \frac{n(n+1)}{2}
\end{align*}

<p>
To be clear, we&rsquo;re not <i>deriving</i> this formula<label for="14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="14" class="margin-toggle"/><span class="sidenote">
The story behind this formula is interesting. See <a href="https://letstalkscience.ca/educational-resources/backgrounders/gauss-summation">this</a> for the
backstory. Note the formula is <br />
\begin{align*}
\frac{\text{(number of pairs)} &sdot; \text{(sum of each pair)}}{2}
\end{align*} <br />
</span>, we&rsquo;re
attempting to <i>prove</i> it. So for example if we add the first three
numbers, according to the formula we should get \(6\;\)
</p>

\begin{align*}
\frac{(3)(3+1)}{2} = \frac{(12)}{2} = 6
\end{align*}

<p>
An induction proof is a two-step process: a <i>base case</i> and an
<i>induction step</i>
</p>

<p>
<b>Base case</b>: \(P(0)\)
</p>

<p>
\(P(0)\;\) is trivial. Just plug in \(0\)
</p>

\begin{align*}
\frac{(0)(0+1)}{2} = \frac{(0\cdot1)}{2} = 0
\end{align*}

<p>
<b>Inductive step</b>: Now we have to consider \(n \gt 0\;\) cases. The whole
idea is to show that for any number \(k \ge 0\;\), if \(P(k)\;\) works, so
will \(P(k+1)\;\)
</p>

<p>
We start by assuming what is called the <i>induction hypothesis</i>, i.e.,
that our statement \(P\) will hold for \(P(n)\;\). Here we&rsquo;re saying for
the unique case when \(n = k\;\) that \(P(k)\;\) is true
</p>

\begin{align}
0 + 1 + 2 + \ldots + k = \frac{k(k+1)}{2}
\end{align}

<p>
Good. Now we want to consider \(P(k+1)\;\). We&rsquo;ll just add it on both
sides since it is the next step after \(k\;\)
</p>

\begin{align*}
(0 + 1 + 2 + \ldots + k) + (k + 1) = \frac{k(k+1)}{2} + (k+1)
\end{align*}

<p>
Now, we consider just the right side of this equation and do some
algebraic manipulation
</p>

\begin{align*}
\frac{k(k+1)}{2} + (k+1) &= \frac{k(k+1)}{2} + \frac{2(k+1)}{2} \\
                         &= \frac{k(k+1)+2(k+1)}{2}
                         &= \frac{(k+1)(k+2)}{2}
                         &= \frac{(k+1)((k+1)+1)}{2}  
\end{align*}

<p>
Going back to our original left-hand side
</p>

\begin{align}
(0 + 1 + 2 + \ldots + k) + (k + 1) = \frac{(k+1)((k+1)+1)}{2}
\end{align}

<p>
Now, compare (6) with (7). On the left-hand side of (7) we have the
next step \((k+1)\;\) and on the right-hand side of (7) we have in the
numerator the &ldquo;number of pairs&rdquo; increased from \(k\;\) to \(k+1\;\) and
the &ldquo;sum of each pair&rdquo; likewise increased by \(1\;\) from \(k+1\) to \(k +
1 + 1\;\). Through algebraic manipulation we have proved that &ldquo;the next
one&rdquo; will indeed increase as we might want it to. For example, if we
total the first ten numbers
</p>

\begin{align*}
\text{Total sum} = \frac{10 \cdot 11}{2}
\end{align*}

<p>
and totalling the next number \(11\) will just be
</p>

\begin{align*}
\text{Total sum} = \frac{11 \cdot 12}{2}
\end{align*}

<p>
which is covered in our proof for <i>any</i> \(k+1\;\).
</p>
</div>
</div>

<div id="outline-container-org8084541" class="outline-4">
<h4 id="org8084541">The &ldquo;missing number&rdquo; question</h4>
<div class="outline-text-4" id="text-org8084541">
<p>
We&rsquo;ll do a Haskell example where Gauss&rsquo; summing formula will be of
use.
</p>

<p>
<font color = "#4715b3">
â² In a sequence on natural numbers \(1 \ldots n\;\) one of the numbers \(k\;\)
is missing, e.g., \(1, \ldots, k-1, k+1, \ldots, n\;\). Find which
number it is.
</font>
</p>

<p>
If we have a relatively short list we can no doubt spot it, e.g.,
\(1,2,4,5\;\); obviously \(3\;\) is missing. But what if our sequence is
thousands of numbers long. For example, with Haskell&rsquo;s list completion
we can create a list representing a very big sequence
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>100<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]
</pre>


<p>
Still doable, but for a sequence going from \(1\) to \(1,000\) it would be
hard to spot the missing number. One solution would be to recurse
through the list testing each number that it was the next after the
previous
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">missingNumberGen</span> n m <span class="org-haskell-operator">|</span> 
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">missingTest1</span> xs
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>
</div>
</div>


<div id="outline-container-org5889dcc" class="outline-4">
<h4 id="org5889dcc">Recurrence relations</h4>
<div class="outline-text-4" id="text-org5889dcc">
<p>
For example, what if we add up the first three
consecutive odd numbers
</p>

<p>
Peano postulated <i>axioms</i>,
givens, starting points. Using set theory methods, he attempted to 
</p>

<p>
According to a modern treatment, there are five basic Peano axioms<label for="15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="15" class="margin-toggle"/><span class="sidenote">
Peano actually had nine axioms; however, four of these deal
with the equality of his natural numbers, which we&rsquo;ll deal with later
when we explore <i>relations</i>, a more general concept above functions.
</span>. The
first axiom states
</p>

<ol class="org-ol">
<li><font color = "#4715b3">\(0\) is a natural number, i.e., \(0
   \in \mathbb{N}\) </font></li>
</ol>

<p>
This is our starting point. Peano then gives four axioms to establish
<i>equality</i>
</p>

<ol class="org-ol">
<li value="2"><font color = "#4715b3"> For every natural number
\(n\), \(S(n)\;\) is a natural number. That is, the natural numbers
are closed under \(S\;\). Or \(x \in \mathbb{N} \rightarrow Sx \in \mathbb{N}\;\;\).
</font></li>
</ol>


<ol class="org-ol">
<li><font color = "#4715b3">For all natural numbers x and y, if x = y, then y = x. That is, equality is symmetric.</font>
<ol class="org-ol">
<li></li>
</ol></li>
</ol>
</div>
</div>
</div>



<div id="outline-container-org42e273c" class="outline-3">
<h3 id="org42e273c">Closures</h3>
<div class="outline-text-3" id="text-org42e273c">
<p>
From the <i>LibreTexts series</i> on Discrete Mathematics, we saw the
concept of <i><a href="https://math.libretexts.org/Courses/Monroe_Community_College/MTH_220_Discrete_Math/1%3A_Introduction_to_Discrete_Mathematics/1.5%3A_Introduction_to_Sets_and_Real_Numbers">sets</a></i> and how they formalize our ideas about
numbers. Again, think of the <i>set</i> of natural numbers. In set notation
we can list just a few <i>consecutive</i>, <i>distinct</i> numbers, then rely on
ellipses, (&#x2026;), to indicate &ldquo;continue with this consecutive, distinct
number pattern&rdquo;
</p>

\begin{align*}
\mathbb{N} = \{0,1,2,3,\ldots \}
\end{align*}

<p>
This is a more abstract and probably more precise set notation for
\(\mathbb{N}\;\) than the previous word-based one. But again we&rsquo;re
assuming ordinality without actually defining it. And notice how our
\(\mathbb{N}\;\) depiction contains no negative numbers<label for="16" class="margin-toggle sidenote-number"></label><input type="checkbox" id="16" class="margin-toggle"/><span class="sidenote">
Some treatments do not consider zero a natural counting number
and use \(\mathbb{N}_0\) to symbolize the natural numbers <i>including</i>
zero.
</span>. Again,
what consequence does that have on doing arithmetic on \(\mathbb{N}\;\)?
For one, how would we do subtraction? Won&rsquo;t that crash if we try to
take a bigger number from a smaller number<label for="17" class="margin-toggle sidenote-number"></label><input type="checkbox" id="17" class="margin-toggle"/><span class="sidenote">
Supposedly, the idea of negative numbers came from the banking
world of the medieval age. So if I give you something that costs three
ducats and you only have two, then you <b>owe</b> me one ducat.
</span>? Subtraction is a
<i>binary operation</i><label for="18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="18" class="margin-toggle"/><span class="sidenote">
We&rsquo;ll have more to say about binary operations when we look
into functions.
</span> of taking one amount from another. Asking in
higher-math-speak, <font color = "#4715b3">does the
binary operation of subtractions on all possible pairs of \(\mathbb{N}\)
yield results that <i>stay inside of</i> \(\mathbb{N}\;\)?</font>
</p>


\begin{align*}
\{(b -a) \in\,\mathbb{N}\; |\; a \in \mathbb{N},\: b \in \mathbb{N}\}
\end{align*}

<p>
or generally, where \(\circ\) means any sort of operator, e.g., \(+\),
\(-\), \(\div\), etc.
</p>

\begin{align*}
\{    \}
\end{align*}



<p>
Apparently not.
</p>

<p>
In more formal language, <font color = "#4715b3">the binary
operation of subtraction <i>on</i> (the members of) some set \(S\) will
assign to each and every possible pair \(a, b \in S\;\) a unique element
\(c \in S\) where \(c = a - b\). </font> That is, a binary
operation combines any two elements of the set to produce a third
element of that same set.
</p>

<p>
If you study this wording closely, it is definitely saying there can
be no such binary operator subtraction on \(\mathbb{N}\) because \(c\) can
definitely fall outside of \(\mathbb{N}\) &#x2014;as it does when, e.g., \(a =
6\) and \(b = 10\;\).<label for="19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="19" class="margin-toggle"/><span class="sidenote">
Peruse <a href="https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/First-Semester_Abstract_Algebra%3A_A_Structural_Approach_(Sklar)/02%3A_Groups/2.01%3A_Binary_Operations_and_Structures">this</a> treatment of binary operations. Again, we&rsquo;ll dive
in deeper later.
</span> In math-speak, a binary operation \(a
\circ b\;\) must be <i>well-defined</i> and <i>inside of</i> \(S\)
</p>

<p>
\(\mathfrak{Fazit}\:\): The binary operation of subtraction is <i>not</i>
<b>closed</b> on \(\mathbb{N}\;\).
</p>


<p>
(Proof of addition on \(\mathbb{N}\;\)?)
</p>

<p>
Semigroups
</p>
</div>
</div>










<div id="outline-container-orgad3828f" class="outline-3">
<h3 id="orgad3828f">Unary numeral system</h3>
<div class="outline-text-3" id="text-orgad3828f">
<p>
There is the <i><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">unary numeral system</a></i> (UNS) where numbers are
represented in a <i>unary</i><label for="20" class="margin-toggle sidenote-number"></label><input type="checkbox" id="20" class="margin-toggle"/><span class="sidenote">
Unfortunately, <i>unary</i> here has two meanings. It means we&rsquo;re
only using one numeral to do our counting, <i>and</i> it indicates a unary
function, i.e., a function that takes only one value and returns only
something from its domain&#x2014;which is a very abstract version of the
idea of a <i>unary operator</i> where only one thing is operated on. For
example, addition is a <i>binary operation</i> since it takes <i>two</i> numbers
and adds them. But making a number a negative number by placing the
negative sign in front of the number is an example of a unary
operation.
</span> way, e.g., one is \(1\), two is \(11\),
three is \(111\), et cetera. The UNS system is not really positional,
i.e., the column of a \(1\) is immaterial since the \(1\)&rsquo;s are completely
interchangeable&#x2014;although when we want to go up a number, we do have
to move everything over one column. But again, the columns do not
indicate anything numerically as columns do with, e.g., our decimal
system<label for="21" class="margin-toggle sidenote-number"></label><input type="checkbox" id="21" class="margin-toggle"/><span class="sidenote">
More on the <i>binary</i> number system later.
</span>.
</p>

<p>
How would we add or subtract in our UNS system? Ironically, we could
invent a sort of columnar subtracting borrowing from decimal vertical
subtraction
</p>

\begin{array}{r}
&11111\\
-\!\!\!\!\!\!&11\\
\hline
&11100
\end{array}

<p>
then we just throw out the zeroes and count up the ones. But we can&rsquo;t
really do addition vertically. Perhaps not vertically but
horizontally
</p>

\begin{align*}
11111 + 11 = 1111111
\end{align*}

<p>
We could also remove the \(+\) and run together or <i>concatenate</i> the
\(1\)&rsquo;s. More on concatenation later.
</p>

<p>
Next, we write some Haskell code to do UNS subtraction<label for="22" class="margin-toggle sidenote-number"></label><input type="checkbox" id="22" class="margin-toggle"/><span class="sidenote">
Make sure you&rsquo;ve got past Chapter 6, <i>Higher Order Functions</i>
in LYAHFGG.
</span>
</p>
</div>

<div id="outline-container-org2029de2" class="outline-5">
<h5 id="org2029de2">UNS Subtraction</h5>
<div class="outline-text-5" id="text-org2029de2">
<p>
Turning math into code means we must first decide which data structure
to use. For our string of \(1\)&rsquo;s we will use the Haskell <i>list</i> data
structure. This may seem ironic to a budding mathematician who
went down the set theory rabbit holes above. Yes, so much of math can
be seen as <i>set theory</i>-based. And no, a list is not a set. And yes,
Haskell has a library for sets. But as beginners we will simulate sets
with lists<label for="23" class="margin-toggle sidenote-number"></label><input type="checkbox" id="23" class="margin-toggle"/><span class="sidenote">
We could also represent our \(1\)&rsquo;s as a string, i.e., like text
between double-quotes, but any string in Haskell is just a list of the
text&rsquo;s individual characters, e.g., <code>"1111"</code> is really just
<code>['1','1','1','1']</code>.
</span>. This means our set of \(1\)&rsquo;s will be represented as
a list with the integer \(1\) repeated as its elements, e.g.,
<code>[1,1,1,1,1]</code> is \(11111\).
</p>

<p>
First we&rsquo;ll try a really primitive way to do UNS subtraction
</p>

<ul class="org-ul">
<li>Put \(1\)&rsquo;s into lists,</li>
<li>Apply the built-in list element counter function, <a href="http://zvon.org/other/haskell/Outputprelude/length_f.html">length</a>, on each to
count the number of \(1\)&rsquo;s in each,</li>
<li>Subtract one from the other.</li>
</ul>

<p>
Not very enlightening, but it works
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
2
</pre>


<p>
We can write our own function <code>uns1</code> for this taking two values as
input
</p>

<pre class="code"><code><span class="org-haskell-definition">uns1</span> list1 list2 <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list2<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">uns1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
2
</pre>




<p>
Now, let&rsquo;s create a better function utilizing Haskell&rsquo;s type and
recursion features
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub2</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub2 l1x l2x
</code></pre>

<p>
We&rsquo;re relying on Haskell&rsquo;s pattern matching and guards to accomplish
loop-like behavior &#x2026; a lot at once. 
</p>

<p>
It seems to work when the subtrahend is smaller than the minuend
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1]
</pre>


<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
But the following test exposes a problem, i.e., <code>unsSub2</code> gets things
backwards when the subtrahend is larger than the minuend. This is a
<i>logic error</i>, i.e., the code evaluates and runs, but produces bad
output
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1]
</pre>


<p>
We can correct this by changing the second line <code>3</code>
</p>

<pre class="code"><code><span class="linenr">1: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">2: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="linenr">3: </span><span class="org-haskell-definition">unsSub21</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="linenr">4: </span>                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="linenr">5: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub21 l1x l2x
<span class="linenr">6: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
Now it works
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
Another attempt would have us turn any extra \(1\)&rsquo;s in the minuend
turned into \(-1\)&rsquo;s. No, it&rsquo;s not exactly UNS, but we&rsquo;re just
practicing here. <code>unsSub3</code> below should do it, but the first
evaluation gives an error<label for="24" class="margin-toggle sidenote-number"></label><input type="checkbox" id="24" class="margin-toggle"/><span class="sidenote">
Eventually you&rsquo;ll be a pro with Haskell error messages, but
for now we&rsquo;ll just have to puzzle them out.
</span>: There is something wrong with the
type declaration.
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</code></pre>

<pre class="example" id="org2338be8">
No instance for (Num a) arising from a use of ânegateâ
  ...
</pre>

<p>
One trick is to simply comment out your type declaration and try again
</p>

<pre class="code"><code><span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub3 :: [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</code></pre>

<p>
When we allow Haskell to infer the type, we have success.
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t unsSub3
</code></pre>

<pre class="example">
unsSub3 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>


<p>
Because we&rsquo;re using <code>negate</code> our list type <code>[a]</code> cannot be just
anything, rather, the <code>a</code>&rsquo;s, the list elements, must be instances
of the class <code>Num</code>. Retrying with Haskell&rsquo;s type declaration
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Num</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
this evaluates. Now
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[-1,-1,-1]
</pre>


<p>
One improvement would be to make sure our input lists are made up of
just ones. For this we have a choice of Haskell built-ins like
<code>filter</code>, <code>all</code>, <code>map</code>, <code>any</code>, and <code>elem</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">list1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">list2</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<p>
One version using <code>any</code> to test for not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> list2
</code></pre>

<pre class="example">
True
</pre>


<p>
Another version of testing for not equal to <code>1</code> using a (lambda)
anonymous function
</p>

<pre class="code"><code><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> list2  <span class="org-comment-delimiter">-- </span><span class="org-comment">checks if any in the list conform to test</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We can test <i>two</i> lists by using <code>Boolean</code> <i>or</i> <code>(||)</code> 
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list2<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
<code>filter</code> returns a list with elements conforming to the test
</p>

<pre class="code"><code><span class="org-haskell-definition">filter</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
<code>all</code> checks if all elements conform to test and returns <code>Boolean</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,2<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
False
</pre>


<p>
<code>map</code>, (see <a href="http://learnyouahaskell.com/higher-order-functions#maps-and-filters">Maps and filters</a>) which we&rsquo;ll use extensively, applies the
test to a list and outputs a new list with the outcomes of each test
on each input list element. Here the test is an anonymous function
testing again for not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">map</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&gt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&lt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,2,3,4<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[True,False,True,True,True]
</pre>


<p>
<code>elem</code> with type <code>Eq a =&gt; a -&gt; [a] -&gt; Bool</code> is not quite as handy
since it doesn&rsquo;t allow for a <code>Boolean</code> predicate test. So yes, we
could test if <code>1</code> is an element of a list, but not if <i>all</i> are
</p>

<pre class="code"><code><span class="org-haskell-definition">elem</span> 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">||</span> elem 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,2,3<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We can &ldquo;trick&rdquo; <code>elem</code> into helping us. First, we produce a list
created from <code>map</code> as above testing each element for <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">map</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[False,False,True,False]
</pre>


<p>
Then <code>elem</code> will tell us if any elements were not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">elem</span> <span class="org-haskell-constructor">True</span> <span class="org-haskell-operator">$</span> map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We&rsquo;ll build in a test using <code>any</code>, but like before, this code doesn&rsquo;t
evaluate properly
</p>

<pre class="example" id="org1d12a27">
unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
unsSub4 l1x l2x | (any (\x -&gt; x /= 1) l1x) || (any (\y -&gt; y /= 1) l2x) = []
unsSub4 l1x l2x | null l1x = (map negate l2x)
                | null l2x = l1x
unsSub4 (l1:l1x) (l2:l2x) = unsSub4 l1x l2x
</pre>

<p>
The error once again complains of something to do with the elements
<code>a</code> of the input arrays
</p>

<pre class="example" id="org59d290a">
Could not deduce (Eq a) arising from a use of â/=â
...
Possible fix:
        add (Eq a) to the context of
          the type signature for:
            unsSub4 :: forall a. Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>

<p>
Again, we&rsquo;ll leave out a type declaration and see what Haskell thinks
it is
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t unsSub4
</code></pre>

<pre class="example">
unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]
</pre>


<p>
Trying this
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub4</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
and it evaluates. What&rsquo;s happening? As before, the input element <code>a</code>&rsquo;s
type must also be an instance of the <code>Eq</code> class, which means there has
to be a way to <i>equate</i> any pair of <code>a</code>&rsquo;s
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</code></pre>

<pre class="example" id="org8684d33">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in âghc-prim-0.6.1:GHC.Classesâ
instance (Eq a, Eq b) =&gt; Eq (Either a b)
  -- Defined in âData.Eitherâ
instance Eq a =&gt; Eq [a] -- Defined in âghc-prim-0.6.1:GHC.Classesâ
instance Eq Word -- Defined in âghc-prim-0.6.1:GHC.Classesâ
instance Eq Ordering -- Defined in âghc-prim-0.6.1:GHC.Classesâ
instance Eq Int -- Defined in âghc-prim-0.6.1:GHC.Classesâ
...
</pre>

<p>
What <code>:i</code> or <code>:info</code> is saying about the typeclass <code>Eq</code> is that in
order to be an instance of it, input <code>a</code> must have defined what
happens when two of its members are subjected to an equality tests
<code>(==)</code> and <code>(/=)</code>.
</p>

<p>
Now <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code> restricts <code>a</code> to
being a value that has instances for <code>Eq</code> <i>and</i> <code>Num</code> registered. Why
is this important? Because without specifying, <i>anticipating</i> the
ability to perform equality (<code>Eq</code>) comparisons on only numerical
values (<code>Num</code>), other non-numerical values for <code>a</code> might give false
output. When we declare the function <code>unsSub4</code>&rsquo;s input and output
types with <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code>, we are
guaranteeing sane behavior.
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,2<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
What will happen if we use lists of strings of <code>1</code>?
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:2516:1-35: error:
    â¢ No instance for (Num [Char]) arising from a use of âunsSub4â
    â¢ In the expression: unsSub4 ["1", "1"] ["1", "1", "1", "1"]
      In an equation for âitâ:
          it = unsSub4 ["1", "1"] ["1", "1", "1", ....]
</pre>


<p>
Again, Haskell is playing it safe. We haven&rsquo;t made Haskell aware of
any way to handle strings as list elements. We use <code>(/=)</code>, which will work
</p>

<pre class="code"><code><span class="org-string">'1'</span> <span class="org-haskell-operator">/=</span> <span class="org-string">'2'</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
but we haven&rsquo;t accounted for <code>negate</code> which wants to negate an actual
number. Looking into <code>negate</code>&rsquo;s type
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t negate
</code></pre>

<pre class="example">
negate :: Num a =&gt; a -&gt; a
</pre>


<p>
we see it cannot handle anything but numbers registered with the
typeclass <code>Num</code>. So yes, we can use string versions of <code>1</code>, but that&rsquo;s
because there is a registered instance for <code>Char</code> which defines behind
the scenes how to equate numbers
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</code></pre>

<pre class="example" id="org50bcfae">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in âghc-prim-0.6.1:GHC.Classesâ
...
instance Eq Char -- Defined in âghc-prim-0.6.1:GHC.Classesâ
...
</pre>
</div>
</div>

<div id="outline-container-org84e15f9" class="outline-5">
<h5 id="org84e15f9">UNS Addition</h5>
<div class="outline-text-5" id="text-org84e15f9">
<p>
As you saw in LYAHFGG, recursion is the Haskell way of looping. UNS
addition, as represented by lists, will be a simple matter of
combining two lists of <code>1</code>&rsquo;s into one total list. Borrowing from
above, we can start out very simple by concatenating the lists
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">++</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1,1,1,1]
</pre>


<pre class="code"><code><span class="org-haskell-definition">uns2</span> list1 list2 <span class="org-haskell-operator">=</span> list1 <span class="org-haskell-operator">++</span> list2
</code></pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd1</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd1 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1]
</pre>


<p>
<code>unsAdd1</code> gives a nice example of recursion. But what if any of the
list elements are negative <code>1</code>&rsquo;s? Let&rsquo;s say if the lists contain
<code>-1</code>&rsquo;s we&rsquo;ll take away a positive <code>1</code>. One approach would be to just
concatenate both lists, then go through removing positive and negative
pairs
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
                  <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd2 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,-1,1,-1,-1]
</pre>


<p>
Here&rsquo;s a variant where the test for <code>1</code> and <code>-1</code> is somewhat shorter
building on this idea
</p>

<pre class="code"><code><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-2">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>



<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&amp;&amp;</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,-1,1,-1,-1]
</pre>


<p>
One simple idea would be to use a <i>fold</i>, e.g.
</p>

<pre class="code"><code><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
3
</pre>


<pre class="code"><code><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
-1
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd4</span> l1x l2x <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> ux <span class="org-haskell-operator">=</span> l1x <span class="org-haskell-operator">++</span> l2x
                  <span class="org-haskell-keyword">in</span> collps ux
                     <span class="org-haskell-keyword">where</span> collps <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-2">)</span> 0
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
2
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd5</span> ux <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> pux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-2">)</span> ux
                 mux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> ux
             <span class="org-haskell-keyword">in</span> pux <span class="org-haskell-operator">++</span> mux
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd5</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1,1,1,1,1,1,-1,-1,-1,-1]
</pre>
</div>
</div>

<div id="outline-container-org8b9ee8f" class="outline-4">
<h4 id="org8b9ee8f">In closing: Some UNS Theory</h4>
<div class="outline-text-4" id="text-org8b9ee8f">
<p>
The UNS is considered a <i>bijective base-1 numeral system</i>. How is
<i>bijective</i> meant here? The answer is to imagine the set of all whole
numerals \(1,2,\ldots,\infin\;\), and then the set of all UNS 1-strings,
e.g., <code>1</code>, <code>11</code>, <code>111</code>. These two sets are mapped bijectively, as with
bijective functions. The term <i>unary</i> can be interpreted mainly as a
number system having only one digit. However, when we explore Peano
numbers, we will revisit the idea of unary functions and unary
operators.
</p>
</div>
</div>
</div>


<div id="outline-container-orgc7f31d5" class="outline-3">
<h3 id="orgc7f31d5">Binary number system</h3>
<div class="outline-text-3" id="text-orgc7f31d5">
<p>
The unary system
</p>
</div>
</div>


<div id="outline-container-orge7550b7" class="outline-3">
<h3 id="orge7550b7">Real numbers are based upon&#x2026;</h3>
<div class="outline-text-3" id="text-orge7550b7">
<p>
Or we could say &ldquo;the number after
four.&rdquo; But that&rsquo;s just the number after three&#x2014;and so on until we
arrive at zero, which we call, yes, zero, and write as \(0\). So in this
system, \(5\) would be&#x2026;
</p>

<p>
<p style="padding-left: 30px">
<font color = "#4715b3">
&#x2026;the next, next, next, next, next number after zero.
</font>
</p>
</p>

<p>
But just to check this for accuracy, we again fall back on numerical
symbols and names. So we count the number of <i>next</i>&rsquo;s and translate
this chain of next links back into \(5\).
</p>

<p>
So we seem to be stuck with names and symbols, our <i>numbering system</i>,
so to speak, to even get off the ground with numbers as representative
of amounts. However, mathematics will want to take us much further
into the conceptualization of numbers, abstractions far beyond the
simple notion of how many. In abstract algebra, operations on numbers
such as addition and subtraction have consequences beyond number names
or symbols. So the subtraction of one natural number from another is a
&ldquo;taking away&rdquo; of one amount from another. But what if we try to take
\(3\) from \(2\;\)? To take \(3\) from \(2\) would land us outside the
counting whole numbers \(\mathbb{N}\;\), would it not?  After all, \(2 -
3\) is \(-1\), i.e., we went past \(0\) and landed one tick below in
&ldquo;negative territory.&rdquo; The <i>integers</i> (denoted by \(\mathbb{Z}\))
abstracts \(\mathbb{N}\;\) by symmetrically mirroring, duplicating all
its positive whole numbers into their negative counterparts. However,
the operation of addition in \(\mathbb{N}\) would not ever take us into
negatives. Any two (sic) natural numbers we might add together would
produce another member of the natural numbers somewhere further up the
list of \(\mathbb{N}\;\). But now we&rsquo;re concerned with where in the
list. Hence, <i>order</i> is our next abstraction beyond just naming
amounts. And as you might suspect, the most basic ordering of numbers
is to &ldquo;line them up&rdquo; according to their amounts<label for="25" class="margin-toggle sidenote-number"></label><input type="checkbox" id="25" class="margin-toggle"/><span class="sidenote">
How would you order a box of crayons? One way would be
by their colors. But is brown ahead or behind green? Crayon colors
don&rsquo;t seem to have an ahead or behind, maybe just a &ldquo;beside&rdquo; or &ldquo;along
with&rdquo; perhaps?
</span>.
</p>

<p>
When we played with the notion of <i>next</i> above, it was as if we
started by feeding a basic starting thing, a <i>zero</i>, into a <i>next
machine</i>, and out came &ldquo;the next thing after zero&rdquo;. We might have
noted that to be \(1\). Then if we feed our zero adorned with next into
the next machine again we get &ldquo;the <i>next</i>, next thing after zero&rdquo; And
we write that down somewhere as \(2\). In effect, we&rsquo;re constructing a
way to string ticks together into a chain, forging a new chain link
for each new tick. Then instead of having a name or symbol, we could
just show the whole chain. Odd and awkward?  But this is exactly what
the Italian mathematician Giuseppe Peano (following up on work done by
the German mathematician Richard Dedekind) formulated in order to put
the notion of natural numbers on a more mathematically-sound footing.
</p>
</div>
</div>
</div>






<div id="outline-container-org657e1fb" class="outline-2">
<h2 id="org657e1fb">Sets</h2>
<div class="outline-text-2" id="text-org657e1fb">
</div>
<div id="outline-container-org1cb5e05" class="outline-3">
<h3 id="org1cb5e05">Set beginnings</h3>
<div class="outline-text-3" id="text-org1cb5e05">
<p>
To check whether two sets are the same one has to check that they have
the same members. The fact that membership is all there is to set
identity, or that sets are fully determined by their members, is
called the <i>principle of extensionality</i>.
</p>

<p>
<i>Set comprehensions</i> are math shorthand for declaring sets
</p>

<p>
ðð­: The set of all natural numbers multiplied by \(2\)
</p>

\begin{align*}
E = \{2n \; | \; n \in \mathbb{N}\}
\end{align*}

<p>
We could now have a variation such as
</p>

\begin{align*}
O = \{n \;|\; n \in \mathbb{N}, n \notin E\}
\end{align*}


<p>
If every member of a set \(A\) is also a member of set \(B\) we say that
\(A\) is a subset of \(B\), written as \(A \subseteq B\). If \(A \subseteq B\)
and \(B \subseteq A\) then it follows by the <i>principle of
extensionality</i> that \(A\) and \(B\) are the same set. Conversely, if \(A
= B\;\) then it follows that \(A \subseteq B\) and \(B \subseteq A\).
</p>

<pre class="code"><code><span class="org-haskell-keyword">let</span> s1 <span class="org-haskell-operator">=</span> Set.fromList <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"a"</span>, <span class="org-string">"b"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="code"><code>s1
</code></pre>

<pre class="example">
fromList ["a","b"]
</pre>







<p>
What about a descriptive definition such as
</p>

\begin{align*}
\text{For allx } x \in P\text{, there existsy } y > x \text{ such that } y \in P.
\end{align*}



<p>
â
<font color = "#4715b3">
For all \(x \in P\), there exists \(y > x\) such that \(y \in P\).
</font> <br />
</p>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span>x,y,z<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, z <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[(True,True,True),(True,True,False),(True,False,True),(True,False,False),(False,True,True),(False,True,False),(False,False,True),(False,False,False)]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-keyword">if</span> y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-keyword">then</span> y <span class="org-haskell-keyword">else</span> 0  <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
fromList ["a","b"]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-haskell-operator">..</span>20<span class="org-rainbow-delimiters-depth-2">]</span>, x <span class="org-haskell-operator">&lt;</span> y <span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10]
</pre>


<pre class="code"><code><span class="org-haskell-definition">filter</span> even <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[2,4,6,8,10]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-rainbow-delimiters-depth-2">(</span>even x<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[2,4,6,8,10]
</pre>





<table id="orgb69be22" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">12</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">48</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">96</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">192</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">384</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">768</td>
</tr>
</tbody>
</table>

<pre class="code"><code>reset
set term svg font "Garamond,25"
set title "Exponential growth" font "CMU serif,15"
set style line 1 lc krgb '#0060ad' lt 1 lw 2 # --- blue
set yrange[0:800]
set xrange[0:10]
set terminal svg size 300,500
plot data with lines ls 1 notitle smooth csplines
</code></pre>


<div id="org28a535b" class="figure">
<p><img src="./images/expo3.svg" alt="expo3.svg" class="org-svg" />
</p>
</div>

<table id="orga9afb4d" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<table id="orgaa64435" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-2</td>
<td class="org-right">-1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">0.25</td>
<td class="org-right">0.5</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<p>
If some process is increasing at an exponential rate, it
means that for each unit of change the rate is growing or decreasing
by a <i>common ratio</i>. In the example above, the common ratio is \(2\).
</p>

<table id="orgf70ea91" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">independent var</th>
<th scope="col" class="org-right">first dependent var</th>
<th scope="col" class="org-right">second dependent var</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0.1</td>
<td class="org-right">0.425</td>
<td class="org-right">0.375</td>
</tr>

<tr>
<td class="org-right">0.2</td>
<td class="org-right">0.3125</td>
<td class="org-right">0.3375</td>
</tr>

<tr>
<td class="org-right">0.3</td>
<td class="org-right">0.24999993</td>
<td class="org-right">0.28333338</td>
</tr>

<tr>
<td class="org-right">0.4</td>
<td class="org-right">0.275</td>
<td class="org-right">0.28125</td>
</tr>

<tr>
<td class="org-right">0.5</td>
<td class="org-right">0.26</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">0.6</td>
<td class="org-right">0.25833338</td>
<td class="org-right">0.24999993</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">0.24642845</td>
<td class="org-right">0.23928553</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">0.23125</td>
<td class="org-right">0.2375</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">0.23333323</td>
<td class="org-right">0.2333332</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0.2225</td>
<td class="org-right">0.22</td>
</tr>

<tr>
<td class="org-right">1.1</td>
<td class="org-right">0.20909075</td>
<td class="org-right">0.22272708</td>
</tr>

<tr>
<td class="org-right">1.2</td>
<td class="org-right">0.19999998</td>
<td class="org-right">0.21458333</td>
</tr>

<tr>
<td class="org-right">1.3</td>
<td class="org-right">0.19615368</td>
<td class="org-right">0.21730748</td>
</tr>

<tr>
<td class="org-right">1.4</td>
<td class="org-right">0.18571433</td>
<td class="org-right">0.21071435</td>
</tr>

<tr>
<td class="org-right">1.5</td>
<td class="org-right">0.19000008</td>
<td class="org-right">0.2150001</td>
</tr>

<tr>
<td class="org-right">1.6</td>
<td class="org-right">0.1828125</td>
<td class="org-right">0.2046875</td>
</tr>

<tr>
<td class="org-right">1.7</td>
<td class="org-right">0.18088253</td>
<td class="org-right">0.1985296</td>
</tr>

<tr>
<td class="org-right">1.8</td>
<td class="org-right">0.17916675</td>
<td class="org-right">0.18888898</td>
</tr>

<tr>
<td class="org-right">1.9</td>
<td class="org-right">0.19342103</td>
<td class="org-right">0.21315783</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0.19</td>
<td class="org-right">0.21625</td>
</tr>

<tr>
<td class="org-right">2.1</td>
<td class="org-right">0.18214268</td>
<td class="org-right">0.20714265</td>
</tr>

<tr>
<td class="org-right">2.2</td>
<td class="org-right">0.17727275</td>
<td class="org-right">0.2022727</td>
</tr>

<tr>
<td class="org-right">2.3</td>
<td class="org-right">0.1739131</td>
<td class="org-right">0.1989131</td>
</tr>

<tr>
<td class="org-right">2.4</td>
<td class="org-right">0.16770833</td>
<td class="org-right">0.1916667</td>
</tr>

<tr>
<td class="org-right">2.5</td>
<td class="org-right">0.164</td>
<td class="org-right">0.188</td>
</tr>

<tr>
<td class="org-right">2.6</td>
<td class="org-right">0.15769238</td>
<td class="org-right">0.18076923</td>
</tr>

<tr>
<td class="org-right">2.7</td>
<td class="org-right">0.1592591</td>
<td class="org-right">0.1888887</td>
</tr>

<tr>
<td class="org-right">2.8</td>
<td class="org-right">0.1598214</td>
<td class="org-right">0.18928565</td>
</tr>

<tr>
<td class="org-right">2.9</td>
<td class="org-right">0.15603453</td>
<td class="org-right">0.1844828</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-orgeea9b78" class="outline-3">
<h3 id="orgeea9b78">Rational numbers</h3>
<div class="outline-text-3" id="text-orgeea9b78">
<p>
In Haskell rational numbers are handled by <code>Data.Ratio</code>
</p>

<pre class="code"><code><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Ratio</span>
</code></pre>

<p>
The basic &ldquo;give back the simplest form&rdquo; function is <code>%</code>
</p>

<pre class="code"><code>50 <span class="org-haskell-operator">%</span> 10
</code></pre>

<pre class="example">
5 % 1
</pre>


<pre class="code"><code><span class="org-haskell-definition">numerator</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
3
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">combRatio :: Ratio</span>
<span class="org-haskell-definition">combRatio</span> r <span class="org-haskell-operator">=</span> show <span class="org-rainbow-delimiters-depth-2">(</span>numerator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">++</span> <span class="org-string">"/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-2">(</span>denominator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">combRatio</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
3/1
</pre>


<p>
â² Tip: Put an infix operator in parentheses to use as prefix
</p>

<pre class="code"><code><span class="org-haskell-definition">r1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">%</span><span class="org-rainbow-delimiters-depth-1">)</span> 50 10
</code></pre>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t r1
</code></pre>

<pre class="example">
r1 :: Integral a =&gt; Ratio a
</pre>


<pre class="code"><code>60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a
</code></pre>

<pre class="example">
3 % 1
</pre>


<pre class="code"><code>60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Rational</span>
</code></pre>

<pre class="example">
3 % 1
</pre>


<p>
First, the data type
</p>

<pre class="code"><code><span class="org-haskell-keyword">data</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">!</span>a <span class="org-haskell-constructor">:%</span> <span class="org-haskell-operator">!</span>a  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span><span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<p>
The <code>:%</code> is a data constructor (the <code>:</code> insures it&rsquo;s a <i>constructor</i>
and not just an operator function) that is placed between the two
<code>Integral</code> parameters. But in the source <code>%</code> calls <code>reduce</code><label for="26" class="margin-toggle sidenote-number"></label><input type="checkbox" id="26" class="margin-toggle"/><span class="sidenote">
<code>quot</code> returns the quotient, discards the remainder; <code>gcd</code> is
the built-in <i>greatest common divisor</i>; <code>signum</code> gives back <code>1</code> if
argument is greater than zero, <code>-1</code> if less than zero, zero if zero.
</span>
</p>

<pre class="code"><code><span class="org-haskell-definition">reduce</span> <span class="org-haskell-operator">::</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
<span class="org-haskell-pragma">{-# SPECIALISE reduce :: Integer -&gt; Integer -&gt; Rational #-}</span>
<span class="org-haskell-definition">reduce</span> <span class="org-haskell-keyword">_</span> 0              <span class="org-haskell-operator">=</span>  ratioZeroDenominatorError
<span class="org-haskell-definition">reduce</span> x y              <span class="org-haskell-operator">=</span>  <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:%</span> <span class="org-rainbow-delimiters-depth-1">(</span>y <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span>
                           <span class="org-haskell-keyword">where</span> d <span class="org-haskell-operator">=</span> gcd x y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-definition">%</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
x <span class="org-haskell-definition">%</span> y <span class="org-haskell-operator">=</span>  reduce <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">*</span> signum y<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>abs y<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">quot</span> 6 3 <span class="org-comment-delimiter">-- </span><span class="org-comment">returns the quotient, discards the remainder, if any</span>
</code></pre>

<pre class="example">
2
</pre>
</div>

<div id="outline-container-orgb3ef737" class="outline-4">
<h4 id="orgb3ef737">GCD and the Euclidean algorithm</h4>
<div class="outline-text-4" id="text-orgb3ef737">
<p>
The built-in Haskell <code>gcd</code> was used to reduce the rational number,
e.g., fraction, to its lowest terms.
</p>

<p>
ðð­. Find the lowest terms of \(42/56\)
</p>

<pre class="code"><code><span class="org-haskell-definition">gcd</span> 42 56
</code></pre>

<pre class="example">
14
</pre>


<p>
i.e., \(14\) is the greatest common divisor of both \(42\) and \(56\)
</p>

<p>
\[
\frac{42}{56}
\]
</p>


<p>
<i>Euclid&rsquo;s algorithm</i>, is an efficient method for computing the
greatest common divisor (GCD) of two integers (numbers), the largest
number that divides them both without a remainder.
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">eGCD</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integral</span> i <span class="org-haskell-operator">=&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i
<span class="org-haskell-definition">eGCD</span> 0 b <span class="org-haskell-operator">=</span> b
<span class="org-haskell-definition">eGCD</span> a b <span class="org-haskell-operator">=</span> eGCD <span class="org-rainbow-delimiters-depth-2">(</span>b <span class="org-haskell-operator">`mod`</span> a<span class="org-rainbow-delimiters-depth-2">)</span> a
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">eGCD</span> 60 25
</code></pre>

<pre class="example">
5
</pre>
</div>
</div>


<div id="outline-container-org370671c" class="outline-4">
<h4 id="org370671c">Perfect numbers</h4>
<div class="outline-text-4" id="text-org370671c">
<p>
This code give the first four <i>perfect numbers</i><label for="27" class="margin-toggle sidenote-number"></label><input type="checkbox" id="27" class="margin-toggle"/><span class="sidenote">
In number theory, a <i>perfect number</i> is a positive integer that
is equal to the sum of its positive divisors, excluding the number
itself. For instance, \(6\) has divisors \(1\), \(2\) and \(3\) (excluding
itself), and \(1 + 2 + 3 = 6\;\), so \(6\) is a perfect number.
</span>
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">let</span> n <span class="org-haskell-operator">=</span> 4
  mapM_ print <span class="org-haskell-operator">$</span>
    take n <span class="org-rainbow-delimiters-depth-2">[</span>candidate <span class="org-haskell-operator">|</span> candidate <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> 2 <span class="org-haskell-operator">^</span> 19<span class="org-rainbow-delimiters-depth-3">]</span>, getSum candidate <span class="org-haskell-operator">==</span> 1 <span class="org-rainbow-delimiters-depth-2">]</span>
    <span class="org-haskell-keyword">where</span>
      getSum candidate <span class="org-haskell-operator">=</span>
        1 <span class="org-haskell-operator">%</span> candidate <span class="org-haskell-operator">+</span> sum <span class="org-rainbow-delimiters-depth-2">[</span>1 <span class="org-haskell-operator">%</span> factor <span class="org-haskell-operator">+</span> 1 <span class="org-haskell-operator">%</span> <span class="org-rainbow-delimiters-depth-3">(</span>candidate <span class="org-haskell-operator">`div`</span> factor<span class="org-rainbow-delimiters-depth-3">)</span>
                            <span class="org-haskell-operator">|</span> factor <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> floor <span class="org-rainbow-delimiters-depth-4">(</span>sqrt <span class="org-rainbow-delimiters-depth-5">(</span>fromIntegral candidate<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
                            , candidate <span class="org-haskell-operator">`mod`</span> factor <span class="org-haskell-operator">==</span> 0 <span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code>main
</code></pre>

<pre class="example">
6
28
496
8128
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f6b663" class="outline-3">
<h3 id="org0f6b663">Power series</h3>
<div class="outline-text-3" id="text-org0f6b663">
<p>
Something<label for="28" class="margin-toggle sidenote-number"></label><input type="checkbox" id="28" class="margin-toggle"/><span class="sidenote">
This is the crummier, brute-force version <br />

<table id="org6b4f8ae" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span> else<label for="29" class="margin-toggle sidenote-number"></label><input type="checkbox" id="29" class="margin-toggle"/><span class="sidenote">
Another attempt <br />

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span>
</p>

<p>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="./images/by-nc-sa.png" width="125px" style="padding: 100px 0px 0px 0px" alt="License-disense"</a>
</p>
</div>
</div>
</div>
<!-- Footnotes --><!-- 
<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
If you&rsquo;re jumping in here make sure you reload <code>numbers1.hs</code>,
along with <code>numbers2.hs</code> from this section&rsquo;s work.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Make sure you&rsquo;ve seen <a href="http://learnyouahaskell.com/starting-out#texas-ranges">Texas ranges</a> in LYAHFGG.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In this next example we use the open-ended &ldquo;infinite&rdquo; list &#x2014;
which will typically go on forever, locking up your computer as it
tries to list <i>all</i> of numbers, or in this case letters. We use the
function <code>take</code> to take just the first <code>27</code> letters and not go any
further. Curiously, Haskell thinks the twenty-seventh letter is
<code>{</code>. That&rsquo;s because these are <i>unicode</i> characters, of which there are
some 1,114,015, according to Haskell. It&rsquo;s usually safe to use an
infinite list with preface functions <br />
<code>Î»&gt; length ['a'..]</code> <br />
<code>1114015</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We&rsquo;ll take apart how Haskell&rsquo;s enumeration-ness class <code>Enum</code>
handles ranges just up ahead.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
&#x2026;with no bigodd nonsense about them &#x2014; a phrase used
repeatedly by the character ironically called Sparkler in Charles
Dickens&rsquo; <i>Little Dorrit</i>.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Russian or <i>matryoshka</i> dolls: <br />
<img src="images/russiandolls.png" alt="russiandolls.png" />  <br />
<br />
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Your mileage may vary. 
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Rewriting is basically what you do when you, e.g., take steps
to simplify or reduce a fraction. More on normal or canonical forms
later.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://www.cmi.ac.in/~madhavan/papers/pdf/programming-language-concepts.pdf">Mukund lecture notes</a>. 
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
At this point we can say induction and recursion (and
recurrence relations in general) are just two sides of the same
coin. Make sure you&rsquo;ve got this <a href="http://learnyouahaskell.com/recursion">LYAHFGG&rsquo;s Recursion</a> chapter under your
belt.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
You may or may not have encountered induction. Typically, a
math course will introduce it as a proof strategy.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<b>zB</b>: German abbreviation for <i>zum Beispiel</i>, or for example.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Propositions are statements or assertions that can be proven
to be either true or false. Make sure you went down <a href="https://math.libretexts.org/Courses/Monroe_Community_College/MTH_220_Discrete_Math/2%3A_Logic/2.1%3A_Propositions">this rabbit hole</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The story behind this formula is interesting. See <a href="https://letstalkscience.ca/educational-resources/backgrounders/gauss-summation">this</a> for the
backstory. Note the formula is <br />
\begin{align*}
\frac{\text{(number of pairs)} &sdot; \text{(sum of each pair)}}{2}
\end{align*} <br />
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Peano actually had nine axioms; however, four of these deal
with the equality of his natural numbers, which we&rsquo;ll deal with later
when we explore <i>relations</i>, a more general concept above functions.
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Some treatments do not consider zero a natural counting number
and use \(\mathbb{N}_0\) to symbolize the natural numbers <i>including</i>
zero.
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Supposedly, the idea of negative numbers came from the banking
world of the medieval age. So if I give you something that costs three
ducats and you only have two, then you <b>owe</b> me one ducat.
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We&rsquo;ll have more to say about binary operations when we look
into functions.
</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Peruse <a href="https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/First-Semester_Abstract_Algebra%3A_A_Structural_Approach_(Sklar)/02%3A_Groups/2.01%3A_Binary_Operations_and_Structures">this</a> treatment of binary operations. Again, we&rsquo;ll dive
in deeper later.
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Unfortunately, <i>unary</i> here has two meanings. It means we&rsquo;re
only using one numeral to do our counting, <i>and</i> it indicates a unary
function, i.e., a function that takes only one value and returns only
something from its domain&#x2014;which is a very abstract version of the
idea of a <i>unary operator</i> where only one thing is operated on. For
example, addition is a <i>binary operation</i> since it takes <i>two</i> numbers
and adds them. But making a number a negative number by placing the
negative sign in front of the number is an example of a unary
operation.
</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
More on the <i>binary</i> number system later.
</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Make sure you&rsquo;ve got past Chapter 6, <i>Higher Order Functions</i>
in LYAHFGG.
</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We could also represent our \(1\)&rsquo;s as a string, i.e., like text
between double-quotes, but any string in Haskell is just a list of the
text&rsquo;s individual characters, e.g., <code>"1111"</code> is really just
<code>['1','1','1','1']</code>.
</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24" role="doc-backlink">24</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Eventually you&rsquo;ll be a pro with Haskell error messages, but
for now we&rsquo;ll just have to puzzle them out.
</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25" role="doc-backlink">25</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
How would you order a box of crayons? One way would be
by their colors. But is brown ahead or behind green? Crayon colors
don&rsquo;t seem to have an ahead or behind, maybe just a &ldquo;beside&rdquo; or &ldquo;along
with&rdquo; perhaps?
</p></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26" role="doc-backlink">26</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<code>quot</code> returns the quotient, discards the remainder; <code>gcd</code> is
the built-in <i>greatest common divisor</i>; <code>signum</code> gives back <code>1</code> if
argument is greater than zero, <code>-1</code> if less than zero, zero if zero.
</p></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27" role="doc-backlink">27</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In number theory, a <i>perfect number</i> is a positive integer that
is equal to the sum of its positive divisors, excluding the number
itself. For instance, \(6\) has divisors \(1\), \(2\) and \(3\) (excluding
itself), and \(1 + 2 + 3 = 6\;\), so \(6\) is a perfect number.
</p></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28" role="doc-backlink">28</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
This is the crummier, brute-force version <br />
</p>
<table id="org6b4f8ae" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29" role="doc-backlink">29</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Another attempt <br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></div></div>

 --></div>
</body>
</html>
