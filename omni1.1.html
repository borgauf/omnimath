<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-28 Sat 15:35 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="./tufte.css" type="text/css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "Neo-Euler"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "Neo-Euler"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "left",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<div class="header">
<img src="./images/heading6.png"  style="padding: 0px 0px 22px 0px" alt="3-d graph" class="center">

  <p>My supercool header</p>
</div>

<div id="outline-container-org30e69f5" class="outline-2">
<h2 id="org30e69f5"><span class="section-number-2">1.</span> Numbers<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
Make sure you&rsquo;ve started going down the rabbit holes in
Preliminary Rabbit Holes.
</span></h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1b3fe83" class="outline-3">
<h3 id="org1b3fe83"><span class="section-number-3">1.1.</span> Rabbit holes</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Make sure you&rsquo;ve started going down the rabbit holes in Preliminary
Rabbit Holes.
</p>
</div>
</div>
</div>

<div id="outline-container-org32eaaa1" class="outline-2">
<h2 id="org32eaaa1"><span class="section-number-2">2.</span> Introduction</h2>
<div class="outline-text-2" id="text-2">
<p>
With this section we&rsquo;ll talk about numbers in a fairly theoretical but
not really difficult manner. Along with the rabbit holes above, we&rsquo;ll
do some dives into Haskell that you should be ready for if you&rsquo;ve
followed the <i>Haskell Preliminaries</i> rabbit hole materials (at least
LYAHFFG).
</p>
</div>
</div>

<div id="outline-container-org6f01ae7" class="outline-2">
<h2 id="org6f01ae7"><span class="section-number-2">3.</span> Numbers as algebraic systems</h2>
<div class="outline-text-2" id="text-3">
<p>
Conceptually, our &ldquo;starter set&rdquo; of numbers, the so-called <i>natural
numbers</i> or <i>counting numbers</i>, \(\mathbb{N}\;\), are not hard to
imagine; you&rsquo;ve been using them since Kindergarten. <i>Addition</i> was
never a problem with the natural numbers, i.e., whatever we wanted to
add together from \(\mathbb{N}\) would result in just another member
from \(\mathbb{N}\;\). And since multiplication is just a glorified form
of addition, we&rsquo;re safe there, too. But what happens when we consider
how subtraction and division work on \(\mathbb{N}\;\)? We need to expand
our starter set to deal with answers that lie outside of the positive
natural numbers. For subtraction we need a new set, namely, the
<i>integers</i> \(\mathbb{Z}\;\)<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
From the LibreTexts rabbit hole, think of \(\mathbb{Z}\) as
everything in \(\mathbb{N}\) along with the negative version of all of
\(\mathbb{N}\;\), i.e., \(\mathbb{Z} =
\{\ldots,-3,-2,-1,0,1,2,3,\ldots\}\)
</span>. As you saw in the first rabbit hole
above, mathematics takes a more formal approach to issues like
this. We&rsquo;ll be exploring this formalism here.
</p>
</div>
</div>

<div id="outline-container-orgc0b0be8" class="outline-2">
<h2 id="orgc0b0be8"><span class="section-number-2">4.</span> Natural numbers</h2>
<div class="outline-text-2" id="text-4">
</div>

<div id="outline-container-org93b5bde" class="outline-3">
<h3 id="org93b5bde"><span class="section-number-3">4.1.</span> The natural numbers are the counting numbers</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Taking a stab at a word definition of \(\mathbb{N}\) in a quasi-set notation style
</p>

\begin{align*}
\mathbb{N} = \{\text{all the whole numbers starting with zero}\}
\end{align*}

<p>
But what do we mean by <i>all</i> and, even worse, <i>starting
with</i>?  For example, is there any order<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
The order of a group of things is its <i>ordinality</i>, while the
number of a group of things is its <i>cardinality</i>.
</span> implied, or are these whole
numbers just in whatever order as long as they&rsquo;re <i>after</i> zero? Of
course our intuitive understanding of what counting numbers are saves
us from silly hypothetical questions like this, right?
</p>

<p>
Around the time of Kindergarten we learned a sort of nursery rhyme of
the first ten numbers&#x2014;probably using our fingers as aides. Around
this time, we learned to write the numeric symbols from \(1\) <i>to</i>
\(10\). Next, we wandered into our first serious mathematical
abstraction when we learned about numbers that have two &ldquo;places&rdquo; or
more: ten, eleven, twelve, then the teens, then twenties, thirties
&#x2026; on out to hundreds, and then even thousands. This required an
understanding of <i>positional notation</i><label for="4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="4" class="margin-toggle"/><span class="sidenote">
See <a href="https://en.wikipedia.org/wiki/Positional_notation">Positional notation</a>.
</span> using the ten basic
Arabic numerals, \(0\) to \(9\), and placing them in increasing
powers-of-ten columns. But this was all done at an intuitive level
meant to cement in our minds the fundamental idea that distinct
<i>amounts</i> have distinct designations, i.e., names and numeric symbols.
</p>

<p>
But seriously, how can we indicate five things without the numerical
symbol \(5\) or the word <i>five</i>? We might imitate an old mechanical
watch and bark out <i>tick!</i> five times<label for="5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="5" class="margin-toggle"/><span class="sidenote">
My mechanical pocket watch has a face with Roman numerals
evenly positioned around a circle, twelve main numbers for the hours
with little marks between each number for the minutes and seconds. But
internally, the mechanics only know about ticking; they know nothing
of the numbers and their positions on the watch face. This means the
steady ticking is <i>mapped</i> to the watch face dumbly. Is ticking,
therefore, the most fundamental sort of counting? When combined with a
number display, perhaps.
</span>, hoping that someone is
keeping track of how many ticks there were. But there&rsquo;s the rub: the
whole idea of counting relies on some sort of ordering and enumeration
scheme. Five of something implies one more than four of something,
which in turn implies two more than three things, et cetera. We&rsquo;ll
eventually talk about what the Italian mathematician Giuseppe Peano
put forth about the natural numbers. But first we&rsquo;ll look into the
concept of <i>closures</i> and go down a few rabbit holes as well.
</p>
</div>
</div>

<div id="outline-container-org6969ea3" class="outline-3">
<h3 id="org6969ea3"><span class="section-number-3">4.2.</span> Closures</h3>
<div class="outline-text-3" id="text-4-2">
<p>
From the <i>LibreTexts series</i> on Discrete Mathematics, we saw the
concept of <i>sets</i> and how they formalize our ideas about
numbers. Let&rsquo;s consider the <i>set</i> of natural numbers. In set notation
we can simply rely on ellipses, (&#x2026;), which means &ldquo;continue with
this pattern.&rdquo;
</p>

\begin{align*}
\mathbb{N} = \{0,1,2,3,\ldots \}
\end{align*}

<p>
This is a more abstract and probably more precise set notation for
\(\mathbb{N}\;\) than the previous word-based one. But again we&rsquo;re made
aware that \(\mathbb{N}\;\) contains no negative numbers<label for="6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="6" class="margin-toggle"/><span class="sidenote">
Some treatments do not consider zero a natural counting number
and use \(\mathbb{N}_0\) to symbolize the natural numbers <i>including</i>
zero.
</span>. What
consequence does that have on doing arithmetic on \(\mathbb{N}\;\)? For
one, how would we do subtraction?
</p>

<p>
All right, for a while it would be okay. After all, \(5 - 2\;\) is \(3\)
and \(62 - 61\;\) is \(1\;\) etc. But what about \(6 - 10\;\)? Subtraction
is a <i>binary operation</i><label for="7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="7" class="margin-toggle"/><span class="sidenote">
We&rsquo;ll have more to say about binary operations when we look
into functions.
</span> of taking one number from another. Does
the set of subtractions on all possible pairs of \(\mathbb{N}\) yield
results that <i>stay inside of</i> \(\mathbb{N}\;\)?
</p>

\begin{align*}
\{x \; |\; \exists\,a \in \mathbb{N},\: \exists\, b \in \mathbb{N} : (x = b - a) \in\,\mathbb{N}\}
\end{align*}

<p>
or generally, where \(\circ\) means any sort of operator, e.g., \(+\),
\(-\), \(\div\), etc.
</p>

\begin{align*}
\{    \}
\end{align*}



<p>
Apparently not.
</p>

<p>
In more formal language, <font color = "#4715b3">the binary
operation of subtraction <i>on</i> (the members of) some set \(S\) will
assign to each and every possible pair \(a, b \in S\;\) a unique element
\(c \in S\) where \(c = a - b\). </font> That is, a binary
operation combines any two elements of the set to produce a third
element of that same set.
</p>

<p>
If you study this wording closely, it is definitely saying there can
be no such binary operator subtraction on \(\mathbb{N}\) because \(c\) can
definitely fall outside of \(\mathbb{N}\) &#x2014;as it does when, e.g., \(a =
6\) and \(b = 10\;\).<label for="8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="8" class="margin-toggle"/><span class="sidenote">
Peruse <a href="https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/First-Semester_Abstract_Algebra%3A_A_Structural_Approach_(Sklar)/02%3A_Groups/2.01%3A_Binary_Operations_and_Structures">this</a> treatment of binary operations. Again, we&rsquo;ll dive
in deeper later.
</span> In math-speak, a binary operation \(a
\circ b\;\) must be <i>well-defined</i> and <i>inside of</i> \(S\)
</p>

<p>
\(\mathfrak{Fazit}\:\): The binary operation of subtraction is <i>not</i>
<b>closed</b> on \(\mathbb{N}\;\).
</p>


<p>
(Proof of addition on \(\mathbb{N}\;\)?)
</p>

<p>
Semigroups
</p>
</div>
</div>








<div id="outline-container-org330508b" class="outline-3">
<h3 id="org330508b"><span class="section-number-3">4.3.</span> Peano&rsquo;s approach to the natural numbers</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The nineteenth century saw mathematicians going through an intense
round of mathematical formalism and exactness. They wanted to firm up
the underpinnings of math, clean up sloppy, intuitive, hand-waving
half-understandings and put math on solid, unassailable logical
footing. One such mathematician was Giuseppe Peano.
</p>

<p>
At issue was just what were those most basic mathematical building
blocks, the counting numbers? Sure, there&rsquo;s the Kindergarten version
of \(\mathbb{N}\;\), but was there something foundational underneath
just rattling off numbers like a child? Peano postulated <i>axioms</i>,
givens, starting points. Using set theory methods, he attempted to 
</p>

<p>
According to a modern treatment, there are five basic Peano axioms<label for="9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="9" class="margin-toggle"/><span class="sidenote">
Peano actually had nine axioms; however, four of these deal
with the equality of his natural numbers, which we&rsquo;ll deal with later
when we explore <i>relations</i>, a more general concept above functions.
</span>. The
first axiom states
</p>

<ol class="org-ol">
<li><font color = "#4715b3">\(0\) is a natural number, i.e., \(0
   \in \mathbb{N}\) </font></li>
</ol>

<p>
This is our starting point. Peano then gives four axioms to establish
<i>equality</i>
</p>

<ol class="org-ol">
<li value="2"><font color = "#4715b3"> For every natural number
\(n\), \(S(n)\;\) is a natural number. That is, the natural numbers
are closed under \(S\;\). Or \(x \in \mathbb{N} \rightarrow Sx \in \mathbb{N}\;\;\).
</font></li>
</ol>


<ol class="org-ol">
<li><font color = "#4715b3">For all natural numbers x and y, if x = y, then y = x. That is, equality is symmetric.</font>
<ol class="org-ol">
<li></li>
</ol></li>
</ol>
</div>
</div>




<div id="outline-container-org3aa3acc" class="outline-3">
<h3 id="org3aa3acc"><span class="section-number-3">4.4.</span> Unary numeral system</h3>
<div class="outline-text-3" id="text-4-4">
<p>
There is the <i><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">unary numeral system</a></i> (UNS) where numbers are
represented in a <i>unary</i><label for="10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="10" class="margin-toggle"/><span class="sidenote">
Unfortunately, <i>unary</i> here has two meanings. It means we&rsquo;re
only using one numeral to do our counting, <i>and</i> it indicates a unary
function, i.e., a function that takes only one value and returns only
something from its domain&#x2014;which is a very abstract version of the
idea of a <i>unary operator</i> where only one thing is operated on. For
example, addition is a <i>binary operation</i> since it takes <i>two</i> numbers
and adds them. But making a number a negative number by placing the
negative sign in front of the number is an example of a unary
operation.
</span> way, e.g., one is \(1\), two is \(11\),
three is \(111\), et cetera. The UNS system is not really positional,
i.e., the column of a \(1\) is immaterial since the \(1\)&rsquo;s are completely
interchangeable&#x2014;although when we want to go up a number, we do have
to move everything over one column. But again, the columns do not
indicate anything numerically as columns do with, e.g., our decimal
system<label for="11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="11" class="margin-toggle"/><span class="sidenote">
More on the <i>binary</i> number system later.
</span>.
</p>

<p>
How would we add or subtract in our UNS system? Ironically, we could
invent a sort of columnar subtracting borrowing from decimal vertical
subtraction
</p>

\begin{array}{r}
&11111\\
-\!\!\!\!\!\!&11\\
\hline
&11100
\end{array}

<p>
then we just throw out the zeroes and count up the ones. But we can&rsquo;t
really do addition vertically. Perhaps not vertically but
horizontally
</p>

\begin{align*}
11111 + 11 = 1111111
\end{align*}

<p>
We could also remove the \(+\) and run together or <i>concatenate</i> the
\(1\)&rsquo;s. More on concatenation later.
</p>

<p>
Next, we write some Haskell code to do UNS subtraction<label for="12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="12" class="margin-toggle"/><span class="sidenote">
Make sure you&rsquo;ve got past Chapter 6, <i>Higher Order Functions</i>
in LYAHFGG.
</span>
</p>
</div>

<div id="outline-container-org9a4a234" class="outline-5">
<h5 id="org9a4a234"><span class="section-number-5">4.4.0.1.</span> UNS Subtraction</h5>
<div class="outline-text-5" id="text-4-4-0-1">
<p>
Turning math into code means we must first decide which data structure
to use. For our string of \(1\)&rsquo;s we will use the Haskell <i>list</i> data
structure. This may seem ironic to a budding mathematician who
went down the set theory rabbit holes above. Yes, so much of math can
be seen as <i>set theory</i>-based. And no, a list is not a set. And yes,
Haskell has a library for sets. But as beginners we will simulate sets
with lists<label for="13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="13" class="margin-toggle"/><span class="sidenote">
We could also represent our \(1\)&rsquo;s as a string, i.e., like text
between double-quotes, but any string in Haskell is just a list of the
text&rsquo;s individual characters, e.g., <code>"1111"</code> is really just
<code>['1','1','1','1']</code>.
</span>. This means our set of \(1\)&rsquo;s will be represented as
a list with the integer \(1\) repeated as its elements, e.g.,
<code>[1,1,1,1,1]</code> is \(11111\).
</p>

<p>
First we&rsquo;ll try a really primitive way to do UNS subtraction
</p>

<ul class="org-ul">
<li>Put \(1\)&rsquo;s into lists,</li>
<li>Apply the built-in list element counter function, <a href="http://zvon.org/other/haskell/Outputprelude/length_f.html">length</a>, on each to
count the number of \(1\)&rsquo;s in each,</li>
<li>Subtract one from the other.</li>
</ul>

<p>
Not very enlightening, but it works
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
2
</pre>


<p>
We can write our own function <code>uns1</code> for this taking two values as
input
</p>

<pre class="code"><code><span class="org-haskell-definition">uns1</span> list1 list2 <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list2<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">uns1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
2
</pre>




<p>
Now, let&rsquo;s create a better function utilizing Haskell&rsquo;s type and
recursion features
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub2</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub2 l1x l2x
</code></pre>

<p>
We&rsquo;re relying on Haskell&rsquo;s pattern matching and guards to accomplish
loop-like behavior &#x2026; a lot at once. 
</p>

<p>
It seems to work when the subtrahend is smaller than the minuend
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1]
</pre>


<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
But the following test exposes a problem, i.e., <code>unsSub2</code> gets things
backwards when the subtrahend is larger than the minuend. This is a
<i>logic error</i>, i.e., the code evaluates and runs, but produces bad
output
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1]
</pre>


<p>
We can correct this by changing the second line <code>3</code>
</p>

<pre class="code"><code><span class="linenr">1: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">2: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="linenr">3: </span><span class="org-haskell-definition">unsSub21</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="linenr">4: </span>                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="linenr">5: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub21 l1x l2x
<span class="linenr">6: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
Now it works
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6459:1-8: error:
    • Variable not in scope: unsSub21 :: [a0] -&gt; [a1] -&gt; t
    • Perhaps you meant one of these:
        ‘unsSub2’ (line 5), ‘unsSub3’ (line 9)
</pre>


<p>
Another attempt would have us turn any extra \(1\)&rsquo;s in the minuend
turned into \(-1\)&rsquo;s. No, it&rsquo;s not exactly UNS, but we&rsquo;re just
practicing here. <code>unsSub3</code> below should do it, but the first
evaluation gives an error<label for="14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="14" class="margin-toggle"/><span class="sidenote">
Eventually you&rsquo;ll be a pro with Haskell error messages, but
for now we&rsquo;ll just have to puzzle them out.
</span>: There is something wrong with the
type declaration.
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</code></pre>

<pre class="example" id="orga3e3f10">
No instance for (Num a) arising from a use of ‘negate’
  ...
</pre>

<p>
One trick is to simply comment out your type declaration and try again
</p>

<pre class="code"><code><span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub3 :: [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</code></pre>

<p>
When we allow Haskell to infer the type, we have success.
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t unsSub3
</code></pre>

<pre class="example">
unsSub3 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>


<p>
Because we&rsquo;re using <code>negate</code> our list type <code>[a]</code> cannot be just
anything, rather, the <code>a</code>&rsquo;s, the list elements, must be instances
of the class <code>Num</code>. Retrying with Haskell&rsquo;s type declaration
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Num</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
this evaluates. Now
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6515:10-21: error:
    Not in scope: ‘Set.fromList’
    No module named ‘Set’ is imported.
</pre>


<p>
One improvement would be to make sure our input lists are made up of
just ones. For this we have a choice of Haskell built-ins like
<code>filter</code>, <code>all</code>, <code>map</code>, <code>any</code>, and <code>elem</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">list1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">list2</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<p>
One version using <code>any</code> to test for not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> list2
</code></pre>

<pre class="example">
True
</pre>


<p>
Another version of testing for not equal to <code>1</code> using a (lambda)
anonymous function
</p>

<pre class="code"><code><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> list2  <span class="org-comment-delimiter">-- </span><span class="org-comment">checks if any in the list conform to test</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We can test <i>two</i> lists by using <code>Boolean</code> <i>or</i> <code>(||)</code> 
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list2<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
<code>filter</code> returns a list with elements conforming to the test
</p>

<pre class="code"><code><span class="org-haskell-definition">filter</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[]
</pre>


<p>
<code>all</code> checks if all elements conform to test and returns <code>Boolean</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,2<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
False
</pre>


<p>
<code>map</code>, (see <a href="http://learnyouahaskell.com/higher-order-functions#maps-and-filters">Maps and filters</a>) which we&rsquo;ll use extensively, applies the
test to a list and outputs a new list with the outcomes of each test
on each input list element. Here the test is an anonymous function
testing again for not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">map</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&gt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&lt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,2,3,4<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[True,False,True,True,True]
</pre>


<p>
<code>elem</code> with type <code>Eq a =&gt; a -&gt; [a] -&gt; Bool</code> is not quite as handy
since it doesn&rsquo;t allow for a <code>Boolean</code> predicate test. So yes, we
could test if <code>1</code> is an element of a list, but not if <i>all</i> are
</p>

<pre class="code"><code><span class="org-haskell-definition">elem</span> 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">||</span> elem 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,2,3<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We can &ldquo;trick&rdquo; <code>elem</code> into helping us. First, we produce a list
created from <code>map</code> as above testing each element for <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">map</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[False,False,True,False]
</pre>


<p>
Then <code>elem</code> will tell us if any elements were not equal to <code>1</code>
</p>

<pre class="code"><code><span class="org-haskell-definition">elem</span> <span class="org-haskell-constructor">True</span> <span class="org-haskell-operator">$</span> map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
We&rsquo;ll build in a test using <code>any</code>, but like before, this code doesn&rsquo;t
evaluate properly
</p>

<pre class="example" id="orga30fa63">
unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
unsSub4 l1x l2x | (any (\x -&gt; x /= 1) l1x) || (any (\y -&gt; y /= 1) l2x) = []
unsSub4 l1x l2x | null l1x = (map negate l2x)
                | null l2x = l1x
unsSub4 (l1:l1x) (l2:l2x) = unsSub4 l1x l2x
</pre>

<p>
The error once again complains of something to do with the elements
<code>a</code> of the input arrays
</p>

<pre class="example" id="orgf5e2778">
Could not deduce (Eq a) arising from a use of ‘/=’
...
Possible fix:
        add (Eq a) to the context of
          the type signature for:
            unsSub4 :: forall a. Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>

<p>
Again, we&rsquo;ll leave out a type declaration and see what Haskell thinks
it is
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t unsSub4
</code></pre>

<pre class="example">
&lt;interactive&gt;:1:1-7: error:
    • Variable not in scope: unsSub4
    • Perhaps you meant one of these:
        ‘unsSub2’ (line 5), ‘unsSub3’ (line 9)
</pre>


<p>
Trying this
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub4</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<p>
and it evaluates. What&rsquo;s happening? As before, the input element <code>a</code>&rsquo;s
type must also be an instance of the <code>Eq</code> class, which means there has
to be a way to <i>equate</i> any pair of <code>a</code>&rsquo;s
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</code></pre>

<pre class="example" id="orgd0cc342">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance (Eq a, Eq b) =&gt; Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a =&gt; Eq [a] -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Word -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Ordering -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Int -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
</pre>

<p>
What <code>:i</code> or <code>:info</code> is saying about the typeclass <code>Eq</code> is that in
order to be an instance of it, input <code>a</code> must have defined what
happens when two of its members are subjected to an equality tests
<code>(==)</code> and <code>(/=)</code>.
</p>

<p>
Now <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code> restricts <code>a</code> to
being a value that has instances for <code>Eq</code> <i>and</i> <code>Num</code> registered. Why
is this important? Because without specifying, <i>anticipating</i> the
ability to perform equality (<code>Eq</code>) comparisons on only numerical
values (<code>Num</code>), other non-numerical values for <code>a</code> might give false
output. When we declare the function <code>unsSub4</code>&rsquo;s input and output
types with <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code>, we are
guaranteeing sane behavior.
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,2<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6487:1-7: error:
    • Variable not in scope: unsSub4 :: [a0] -&gt; [a1] -&gt; t
    • Perhaps you meant one of these:
        ‘unsSub2’ (line 5), ‘unsSub3’ (line 9)
</pre>


<p>
What will happen if we use lists of strings of <code>1</code>?
</p>

<pre class="code"><code><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6489:1-7: error:
    • Variable not in scope: unsSub4 :: [String] -&gt; [String] -&gt; t
    • Perhaps you meant one of these:
        ‘unsSub2’ (line 5), ‘unsSub3’ (line 9)
</pre>


<p>
Again, Haskell is playing it safe. We haven&rsquo;t made Haskell aware of
any way to handle strings as list elements. We use <code>(/=)</code>, which will work
</p>

<pre class="code"><code><span class="org-string">'1'</span> <span class="org-haskell-operator">/=</span> <span class="org-string">'2'</span>
</code></pre>

<pre class="example">
True
</pre>


<p>
but we haven&rsquo;t accounted for <code>negate</code> which wants to negate an actual
number. Looking into <code>negate</code>&rsquo;s type
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t negate
</code></pre>

<pre class="example">
negate :: Num a =&gt; a -&gt; a
</pre>


<p>
we see it cannot handle anything but numbers registered with the
typeclass <code>Num</code>. So yes, we can use string versions of <code>1</code>, but that&rsquo;s
because there is a registered instance for <code>Char</code> which defines behind
the scenes how to equate numbers
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</code></pre>

<pre class="example" id="org19907dc">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
instance Eq Char -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
</pre>
</div>
</div>

<div id="outline-container-org743a6e8" class="outline-5">
<h5 id="org743a6e8"><span class="section-number-5">4.4.0.2.</span> UNS Addition</h5>
<div class="outline-text-5" id="text-4-4-0-2">
<p>
As you saw in LYAHFGG, recursion is the Haskell way of looping. UNS
addition, as represented by lists, will be a simple matter of
combining two lists of <code>1</code>&rsquo;s into one total list. Borrowing from
above, we can start out very simple by concatenating the lists
</p>

<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">++</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1,1,1,1]
</pre>


<pre class="code"><code><span class="org-haskell-definition">uns2</span> list1 list2 <span class="org-haskell-operator">=</span> list1 <span class="org-haskell-operator">++</span> list2
</code></pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd1</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd1 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6499:1-7: error:
    Variable not in scope: unsAdd1 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
<code>unsAdd1</code> gives a nice example of recursion. But what if any of the
list elements are negative <code>1</code>&rsquo;s? Let&rsquo;s say if the lists contain
<code>-1</code>&rsquo;s we&rsquo;ll take away a positive <code>1</code>. One approach would be to just
concatenate both lists, then go through removing positive and negative
pairs
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
                  <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd2 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6501:1-7: error:
    Variable not in scope: unsAdd2 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
Here&rsquo;s a variant where the test for <code>1</code> and <code>-1</code> is somewhat shorter
building on this idea
</p>

<pre class="code"><code><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-2">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
True
</pre>



<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&amp;&amp;</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6505:1-7: error:
    Variable not in scope: unsAdd3 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
One simple idea would be to use a <i>fold</i>, e.g.
</p>

<pre class="code"><code><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
3
</pre>


<pre class="code"><code><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
-1
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd4</span> l1x l2x <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> ux <span class="org-haskell-operator">=</span> l1x <span class="org-haskell-operator">++</span> l2x
                  <span class="org-haskell-keyword">in</span> collps ux
                     <span class="org-haskell-keyword">where</span> collps <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-2">)</span> 0
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6511:1-7: error:
    Variable not in scope: unsAdd4 :: [a0] -&gt; [a1] -&gt; t
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd5</span> ux <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> pux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-2">)</span> ux
                 mux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> ux
             <span class="org-haskell-keyword">in</span> pux <span class="org-haskell-operator">++</span> mux
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">unsAdd5</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6513:1-7: error:
    Variable not in scope: unsAdd5 :: [a0] -&gt; t
</pre>
</div>
</div>

<div id="outline-container-org60f1974" class="outline-4">
<h4 id="org60f1974"><span class="section-number-4">4.4.1.</span> In closing: Some UNS Theory</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
The UNS is considered a <i>bijective base-1 numeral system</i>. How is
<i>bijective</i> meant here? The answer is to imagine the set of all whole
numerals \(1,2,\ldots,\infin\;\), and then the set of all UNS 1-strings,
e.g., <code>1</code>, <code>11</code>, <code>111</code>. These two sets are mapped bijectively, as with
bijective functions. The term <i>unary</i> can be interpreted mainly as a
number system having only one digit. However, when we explore Peano
numbers, we will revisit the idea of unary functions and unary
operators.
</p>
</div>
</div>
</div>


<div id="outline-container-org7a3fd38" class="outline-3">
<h3 id="org7a3fd38"><span class="section-number-3">4.5.</span> Binary number system</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The unary system
</p>
</div>
</div>


<div id="outline-container-orgb1ce65a" class="outline-3">
<h3 id="orgb1ce65a"><span class="section-number-3">4.6.</span> Real numbers are based upon&#x2026;</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Or we could say &ldquo;the number after
four.&rdquo; But that&rsquo;s just the number after three&#x2014;and so on until we
arrive at zero, which we call, yes, zero, and write as \(0\). So in this
system, \(5\) would be&#x2026;
</p>

<p>
<p style="padding-left: 30px">
<font color = "#4715b3">
&#x2026;the next, next, next, next, next number after zero.
</font>
</p>
</p>

<p>
But just to check this for accuracy, we again fall back on numerical
symbols and names. So we count the number of <i>next</i>&rsquo;s and translate
this chain of next links back into \(5\).
</p>

<p>
So we seem to be stuck with names and symbols, our <i>numbering system</i>,
so to speak, to even get off the ground with numbers as representative
of amounts. However, mathematics will want to take us much further
into the conceptualization of numbers, abstractions far beyond the
simple notion of how many. In abstract algebra, operations on numbers
such as addition and subtraction have consequences beyond number names
or symbols. So the subtraction of one natural number from another is a
&ldquo;taking away&rdquo; of one amount from another. But what if we try to take
\(3\) from \(2\;\)? To take \(3\) from \(2\) would land us outside the
counting whole numbers \(\mathbb{N}\;\), would it not?  After all, \(2 -
3\) is \(-1\), i.e., we went past \(0\) and landed one tick below in
&ldquo;negative territory.&rdquo; The <i>integers</i> (denoted by \(\mathbb{Z}\))
abstracts \(\mathbb{N}\;\) by symmetrically mirroring, duplicating all
its positive whole numbers into their negative counterparts. However,
the operation of addition in \(\mathbb{N}\) would not ever take us into
negatives. Any two (sic) natural numbers we might add together would
produce another member of the natural numbers somewhere further up the
list of \(\mathbb{N}\;\). But now we&rsquo;re concerned with where in the
list. Hence, <i>order</i> is our next abstraction beyond just naming
amounts. And as you might suspect, the most basic ordering of numbers
is to &ldquo;line them up&rdquo; according to their amounts<label for="15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="15" class="margin-toggle"/><span class="sidenote">
How would you order a box of crayons? One way would be
by their colors. But is brown ahead or behind green? Crayon colors
don&rsquo;t seem to have an ahead or behind, maybe just a &ldquo;beside&rdquo; or &ldquo;along
with&rdquo; perhaps?
</span>.
</p>

<p>
When we played with the notion of <i>next</i> above, it was as if we
started by feeding a basic starting thing, a <i>zero</i>, into a <i>next
machine</i>, and out came &ldquo;the next thing after zero&rdquo;. We might have
noted that to be \(1\). Then if we feed our zero adorned with next into
the next machine again we get &ldquo;the <i>next</i>, next thing after zero&rdquo; And
we write that down somewhere as \(2\). In effect, we&rsquo;re constructing a
way to string ticks together into a chain, forging a new chain link
for each new tick. Then instead of having a name or symbol, we could
just show the whole chain. Odd and awkward?  But this is exactly what
the Italian mathematician Giuseppe Peano (following up on work done by
the German mathematician Richard Dedekind) formulated in order to put
the notion of natural numbers on a more mathematically-sound footing.
</p>
</div>
</div>
</div>






<div id="outline-container-orgabb2f8a" class="outline-2">
<h2 id="orgabb2f8a"><span class="section-number-2">5.</span> Sets</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orga41baf6" class="outline-3">
<h3 id="orga41baf6"><span class="section-number-3">5.1.</span> Set beginnings</h3>
<div class="outline-text-3" id="text-5-1">
<p>
To check whether two sets are the same one has to check that they have
the same members. The fact that membership is all there is to set
identity, or that sets are fully determined by their members, is
called the <i>principle of extensionality</i>.
</p>

<p>
<i>Set comprehensions</i> are math shorthand for declaring sets
</p>

<p>
𝖟𝕭: The set of all natural numbers multiplied by \(2\)
</p>

\begin{align*}
E = \{2n \; | \; n \in \mathbb{N}\}
\end{align*}

<p>
We could now have a variation such as
</p>

\begin{align*}
O = \{n \;|\; n \in \mathbb{N}, n \notin E\}
\end{align*}


<p>
If every member of a set \(A\) is also a member of set \(B\) we say that
\(A\) is a subset of \(B\), written as \(A \subseteq B\). If \(A \subseteq B\)
and \(B \subseteq A\) then it follows by the <i>principle of
extensionality</i> that \(A\) and \(B\) are the same set. Conversely, if \(A
= B\;\) then it follows that \(A \subseteq B\) and \(B \subseteq A\).
</p>

<pre class="code"><code><span class="org-haskell-keyword">let</span> s1 <span class="org-haskell-operator">=</span> Set.fromList <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"a"</span>, <span class="org-string">"b"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="code"><code>s1
</code></pre>

<p>
What about a descriptive definition such as
</p>

\begin{align*}
\text{For allx } x \in P\text{, there existsy } y > x \text{ such that } y \in P.
\end{align*}



<p>
➝
<font color = "#4715b3">
For all \(x \in P\), there exists \(y > x\) such that \(y \in P\).
</font> <br />
</p>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span>x,y,z<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, z <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[(True,True,True),(True,True,False),(True,False,True),(True,False,False),(False,True,True),(False,True,False),(False,False,True),(False,False,False)]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,False,True,True,True,True,True,True,True,True,True,True,True,True,True,False,False,False,True,True,True,True,True,True,True,True,True,True,True,True,False,False,False,False,True,True,True,True,True,True,True,True,True,True,True,False,False,False,False,False,True,True,True,True,True,True,True,True,True,True,False,False,False,False,False,False,True,True,True,True,True,True,True,True,True,False,False,False,False,False,False,False,True,True,True,True,True,True,True,True,False,False,False,False,False,False,False,False,True,True,True,True,True,True,True,False,False,False,False,False,False,False,False,False,True,True,True,True,True,True,False,False,False,False,False,False,False,False,False,False,True,True,True,True,True]
</pre>



<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-keyword">if</span> y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-keyword">then</span> y <span class="org-haskell-keyword">else</span> 0  <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,0,3,4,5,6,7,8,9,10,11,12,13,14,15,0,0,0,4,5,6,7,8,9,10,11,12,13,14,15,0,0,0,0,5,6,7,8,9,10,11,12,13,14,15,0,0,0,0,0,6,7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,11,12,13,14,15]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-haskell-operator">..</span>20<span class="org-rainbow-delimiters-depth-2">]</span>, x <span class="org-haskell-operator">&lt;</span> y <span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10]
</pre>


<pre class="code"><code><span class="org-haskell-definition">filter</span> even <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[2,4,6,8,10]
</pre>


<pre class="code"><code><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-rainbow-delimiters-depth-2">(</span>even x<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</code></pre>

<pre class="example">
[2,4,6,8,10]
</pre>





<table id="org7b102a7" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">12</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">48</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">96</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">192</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">384</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">768</td>
</tr>
</tbody>
</table>


<div id="orgadc50ed" class="figure">
<p><img src="./images/expo3.svg" alt="expo3.svg" class="org-svg" />
</p>
</div>

<table id="org38f82ac" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<table id="org74a2a29" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-2</td>
<td class="org-right">-1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">0.25</td>
<td class="org-right">0.5</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<p>
If some process is increasing at an exponential rate, it
means that for each unit of change the rate is growing or decreasing
by a <i>common ratio</i>. In the example above, the common ratio is \(2\).
</p>

<table id="org0dea7ba" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">independent var</th>
<th scope="col" class="org-right">first dependent var</th>
<th scope="col" class="org-right">second dependent var</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0.1</td>
<td class="org-right">0.425</td>
<td class="org-right">0.375</td>
</tr>

<tr>
<td class="org-right">0.2</td>
<td class="org-right">0.3125</td>
<td class="org-right">0.3375</td>
</tr>

<tr>
<td class="org-right">0.3</td>
<td class="org-right">0.24999993</td>
<td class="org-right">0.28333338</td>
</tr>

<tr>
<td class="org-right">0.4</td>
<td class="org-right">0.275</td>
<td class="org-right">0.28125</td>
</tr>

<tr>
<td class="org-right">0.5</td>
<td class="org-right">0.26</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">0.6</td>
<td class="org-right">0.25833338</td>
<td class="org-right">0.24999993</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">0.24642845</td>
<td class="org-right">0.23928553</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">0.23125</td>
<td class="org-right">0.2375</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">0.23333323</td>
<td class="org-right">0.2333332</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0.2225</td>
<td class="org-right">0.22</td>
</tr>

<tr>
<td class="org-right">1.1</td>
<td class="org-right">0.20909075</td>
<td class="org-right">0.22272708</td>
</tr>

<tr>
<td class="org-right">1.2</td>
<td class="org-right">0.19999998</td>
<td class="org-right">0.21458333</td>
</tr>

<tr>
<td class="org-right">1.3</td>
<td class="org-right">0.19615368</td>
<td class="org-right">0.21730748</td>
</tr>

<tr>
<td class="org-right">1.4</td>
<td class="org-right">0.18571433</td>
<td class="org-right">0.21071435</td>
</tr>

<tr>
<td class="org-right">1.5</td>
<td class="org-right">0.19000008</td>
<td class="org-right">0.2150001</td>
</tr>

<tr>
<td class="org-right">1.6</td>
<td class="org-right">0.1828125</td>
<td class="org-right">0.2046875</td>
</tr>

<tr>
<td class="org-right">1.7</td>
<td class="org-right">0.18088253</td>
<td class="org-right">0.1985296</td>
</tr>

<tr>
<td class="org-right">1.8</td>
<td class="org-right">0.17916675</td>
<td class="org-right">0.18888898</td>
</tr>

<tr>
<td class="org-right">1.9</td>
<td class="org-right">0.19342103</td>
<td class="org-right">0.21315783</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0.19</td>
<td class="org-right">0.21625</td>
</tr>

<tr>
<td class="org-right">2.1</td>
<td class="org-right">0.18214268</td>
<td class="org-right">0.20714265</td>
</tr>

<tr>
<td class="org-right">2.2</td>
<td class="org-right">0.17727275</td>
<td class="org-right">0.2022727</td>
</tr>

<tr>
<td class="org-right">2.3</td>
<td class="org-right">0.1739131</td>
<td class="org-right">0.1989131</td>
</tr>

<tr>
<td class="org-right">2.4</td>
<td class="org-right">0.16770833</td>
<td class="org-right">0.1916667</td>
</tr>

<tr>
<td class="org-right">2.5</td>
<td class="org-right">0.164</td>
<td class="org-right">0.188</td>
</tr>

<tr>
<td class="org-right">2.6</td>
<td class="org-right">0.15769238</td>
<td class="org-right">0.18076923</td>
</tr>

<tr>
<td class="org-right">2.7</td>
<td class="org-right">0.1592591</td>
<td class="org-right">0.1888887</td>
</tr>

<tr>
<td class="org-right">2.8</td>
<td class="org-right">0.1598214</td>
<td class="org-right">0.18928565</td>
</tr>

<tr>
<td class="org-right">2.9</td>
<td class="org-right">0.15603453</td>
<td class="org-right">0.1844828</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org34c2302" class="outline-3">
<h3 id="org34c2302"><span class="section-number-3">5.2.</span> Rational numbers</h3>
<div class="outline-text-3" id="text-5-2">
<p>
In Haskell rational numbers are handled by <code>Data.Ratio</code>
</p>

<pre class="code"><code><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Ratio</span>
</code></pre>

<p>
The basic &ldquo;give back the simplest form&rdquo; function is <code>%</code>
</p>

<pre class="code"><code>50 <span class="org-haskell-operator">%</span> 10
</code></pre>

<pre class="example">
&lt;interactive&gt;:6531:4: error:
    Variable not in scope: (%) :: t0 -&gt; t1 -&gt; t
</pre>


<pre class="code"><code><span class="org-haskell-definition">numerator</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6533:1-9: error:
    Variable not in scope: numerator :: t2 -&gt; t

&lt;interactive&gt;:6533:15: error:
    Variable not in scope: (%) :: t0 -&gt; t1 -&gt; t2
</pre>


<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">combRatio :: Ratio</span>
<span class="org-haskell-definition">combRatio</span> r <span class="org-haskell-operator">=</span> show <span class="org-rainbow-delimiters-depth-2">(</span>numerator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">++</span> <span class="org-string">"/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-2">(</span>denominator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">combRatio</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6535:1-9: error:
    Variable not in scope: combRatio :: t2 -&gt; t

&lt;interactive&gt;:6535:15: error:
    Variable not in scope: (%) :: t0 -&gt; t1 -&gt; t2
</pre>


<p>
⇲ Tip: Put an infix operator in parentheses to use as prefix
</p>

<pre class="code"><code><span class="org-haskell-definition">r1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">%</span><span class="org-rainbow-delimiters-depth-1">)</span> 50 10
</code></pre>

<pre class="code"><code><span class="org-haskell-constructor">:</span>t r1
</code></pre>

<pre class="example">
&lt;interactive&gt;:1:1-2: error: Variable not in scope: r1
</pre>


<pre class="code"><code>60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a
</code></pre>

<pre class="example">
&lt;interactive&gt;:6539:28-32: error:
    Not in scope: type constructor or class ‘Ratio’
    A data constructor of that name is in scope; did you mean DataKinds?
</pre>


<pre class="code"><code>60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Rational</span>
</code></pre>

<pre class="example">
&lt;interactive&gt;:6541:4: error:
    Variable not in scope: (%) :: t0 -&gt; t1 -&gt; Rational
</pre>


<p>
First, the data type
</p>

<pre class="code"><code><span class="org-haskell-keyword">data</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">!</span>a <span class="org-haskell-constructor">:%</span> <span class="org-haskell-operator">!</span>a  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span><span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<p>
The <code>:%</code> is a data constructor (the <code>:</code> insures it&rsquo;s a <i>constructor</i>
and not just an operator function) that is placed between the two
<code>Integral</code> parameters. But in the source <code>%</code> calls <code>reduce</code><label for="16" class="margin-toggle sidenote-number"></label><input type="checkbox" id="16" class="margin-toggle"/><span class="sidenote">
<code>quot</code> returns the quotient, discards the remainder; <code>gcd</code> is
the built-in <i>greatest common divisor</i>; <code>signum</code> gives back <code>1</code> if
argument is greater than zero, <code>-1</code> if less than zero, zero if zero.
</span>
</p>

<pre class="code"><code><span class="org-haskell-definition">reduce</span> <span class="org-haskell-operator">::</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
<span class="org-haskell-pragma">{-# SPECIALISE reduce :: Integer -&gt; Integer -&gt; Rational #-}</span>
<span class="org-haskell-definition">reduce</span> <span class="org-haskell-keyword">_</span> 0              <span class="org-haskell-operator">=</span>  ratioZeroDenominatorError
<span class="org-haskell-definition">reduce</span> x y              <span class="org-haskell-operator">=</span>  <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:%</span> <span class="org-rainbow-delimiters-depth-1">(</span>y <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span>
                           <span class="org-haskell-keyword">where</span> d <span class="org-haskell-operator">=</span> gcd x y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-definition">%</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
x <span class="org-haskell-definition">%</span> y <span class="org-haskell-operator">=</span>  reduce <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">*</span> signum y<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>abs y<span class="org-rainbow-delimiters-depth-1">)</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">quot</span> 6 3 <span class="org-comment-delimiter">-- </span><span class="org-comment">returns the quotient, discards the remainder, if any</span>
</code></pre>

<pre class="example">
2
</pre>
</div>

<div id="outline-container-org7725e4f" class="outline-4">
<h4 id="org7725e4f"><span class="section-number-4">5.2.1.</span> GCD and the Euclidean algorithm</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
The built-in Haskell <code>gcd</code> was used to reduce the rational number,
e.g., fraction, to its lowest terms.
</p>

<p>
𝖟𝕭. Find the lowest terms of \(42/56\)
</p>

<pre class="code"><code><span class="org-haskell-definition">gcd</span> 42 56
</code></pre>

<pre class="example">
14
</pre>


<p>
i.e., \(14\) is the greatest common divisor of both \(42\) and \(56\)
</p>

<p>
\[
\frac{42}{56}
\]
</p>


<p>
<i>Euclid&rsquo;s algorithm</i>, is an efficient method for computing the
greatest common divisor (GCD) of two integers (numbers), the largest
number that divides them both without a remainder.
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">eGCD</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integral</span> i <span class="org-haskell-operator">=&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i
<span class="org-haskell-definition">eGCD</span> 0 b <span class="org-haskell-operator">=</span> b
<span class="org-haskell-definition">eGCD</span> a b <span class="org-haskell-operator">=</span> eGCD <span class="org-rainbow-delimiters-depth-2">(</span>b <span class="org-haskell-operator">`mod`</span> a<span class="org-rainbow-delimiters-depth-2">)</span> a
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code><span class="org-haskell-definition">eGCD</span> 60 25
</code></pre>

<pre class="example">
&lt;interactive&gt;:6547:1-4: error:
    Variable not in scope: eGCD :: t0 -&gt; t1 -&gt; t
</pre>
</div>
</div>


<div id="outline-container-orgf078eb0" class="outline-4">
<h4 id="orgf078eb0"><span class="section-number-4">5.2.2.</span> Perfect numbers</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
This code give the first four <i>perfect numbers</i><label for="17" class="margin-toggle sidenote-number"></label><input type="checkbox" id="17" class="margin-toggle"/><span class="sidenote">
In number theory, a <i>perfect number</i> is a positive integer that
is equal to the sum of its positive divisors, excluding the number
itself. For instance, \(6\) has divisors \(1\), \(2\) and \(3\) (excluding
itself), and \(1 + 2 + 3 = 6\;\), so \(6\) is a perfect number.
</span>
</p>

<pre class="code"><code><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">let</span> n <span class="org-haskell-operator">=</span> 4
  mapM_ print <span class="org-haskell-operator">$</span>
    take n <span class="org-rainbow-delimiters-depth-2">[</span>candidate <span class="org-haskell-operator">|</span> candidate <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> 2 <span class="org-haskell-operator">^</span> 19<span class="org-rainbow-delimiters-depth-3">]</span>, getSum candidate <span class="org-haskell-operator">==</span> 1 <span class="org-rainbow-delimiters-depth-2">]</span>
    <span class="org-haskell-keyword">where</span>
      getSum candidate <span class="org-haskell-operator">=</span>
        1 <span class="org-haskell-operator">%</span> candidate <span class="org-haskell-operator">+</span> sum <span class="org-rainbow-delimiters-depth-2">[</span>1 <span class="org-haskell-operator">%</span> factor <span class="org-haskell-operator">+</span> 1 <span class="org-haskell-operator">%</span> <span class="org-rainbow-delimiters-depth-3">(</span>candidate <span class="org-haskell-operator">`div`</span> factor<span class="org-rainbow-delimiters-depth-3">)</span>
                            <span class="org-haskell-operator">|</span> factor <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> floor <span class="org-rainbow-delimiters-depth-4">(</span>sqrt <span class="org-rainbow-delimiters-depth-5">(</span>fromIntegral candidate<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
                            , candidate <span class="org-haskell-operator">`mod`</span> factor <span class="org-haskell-operator">==</span> 0 <span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</code></pre>

<pre class="code"><code>main
</code></pre>

<pre class="example">
• Perhaps you meant ‘min’ (imported from Prelude)
</pre>
</div>
</div>
</div>

<div id="outline-container-org90df39e" class="outline-3">
<h3 id="org90df39e"><span class="section-number-3">5.3.</span> Power series</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Something<label for="18" class="margin-toggle sidenote-number"></label><input type="checkbox" id="18" class="margin-toggle"/><span class="sidenote">
This is the crummier, brute-force version <br />

<table id="orgf7e8cd8" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span> else<label for="19" class="margin-toggle sidenote-number"></label><input type="checkbox" id="19" class="margin-toggle"/><span class="sidenote">
Another attempt <br />

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span>
</p>
</div>
</div>
</div>
<!-- Footnotes --><!-- 
<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Make sure you&rsquo;ve started going down the rabbit holes in
Preliminary Rabbit Holes.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
From the LibreTexts rabbit hole, think of \(\mathbb{Z}\) as
everything in \(\mathbb{N}\) along with the negative version of all of
\(\mathbb{N}\;\), i.e., \(\mathbb{Z} =
\{\ldots,-3,-2,-1,0,1,2,3,\ldots\}\)
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The order of a group of things is its <i>ordinality</i>, while the
number of a group of things is its <i>cardinality</i>.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
See <a href="https://en.wikipedia.org/wiki/Positional_notation">Positional notation</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
My mechanical pocket watch has a face with Roman numerals
evenly positioned around a circle, twelve main numbers for the hours
with little marks between each number for the minutes and seconds. But
internally, the mechanics only know about ticking; they know nothing
of the numbers and their positions on the watch face. This means the
steady ticking is <i>mapped</i> to the watch face dumbly. Is ticking,
therefore, the most fundamental sort of counting? When combined with a
number display, perhaps.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Some treatments do not consider zero a natural counting number
and use \(\mathbb{N}_0\) to symbolize the natural numbers <i>including</i>
zero.
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We&rsquo;ll have more to say about binary operations when we look
into functions.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Peruse <a href="https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/First-Semester_Abstract_Algebra%3A_A_Structural_Approach_(Sklar)/02%3A_Groups/2.01%3A_Binary_Operations_and_Structures">this</a> treatment of binary operations. Again, we&rsquo;ll dive
in deeper later.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Peano actually had nine axioms; however, four of these deal
with the equality of his natural numbers, which we&rsquo;ll deal with later
when we explore <i>relations</i>, a more general concept above functions.
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Unfortunately, <i>unary</i> here has two meanings. It means we&rsquo;re
only using one numeral to do our counting, <i>and</i> it indicates a unary
function, i.e., a function that takes only one value and returns only
something from its domain&#x2014;which is a very abstract version of the
idea of a <i>unary operator</i> where only one thing is operated on. For
example, addition is a <i>binary operation</i> since it takes <i>two</i> numbers
and adds them. But making a number a negative number by placing the
negative sign in front of the number is an example of a unary
operation.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
More on the <i>binary</i> number system later.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Make sure you&rsquo;ve got past Chapter 6, <i>Higher Order Functions</i>
in LYAHFGG.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We could also represent our \(1\)&rsquo;s as a string, i.e., like text
between double-quotes, but any string in Haskell is just a list of the
text&rsquo;s individual characters, e.g., <code>"1111"</code> is really just
<code>['1','1','1','1']</code>.
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Eventually you&rsquo;ll be a pro with Haskell error messages, but
for now we&rsquo;ll just have to puzzle them out.
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
How would you order a box of crayons? One way would be
by their colors. But is brown ahead or behind green? Crayon colors
don&rsquo;t seem to have an ahead or behind, maybe just a &ldquo;beside&rdquo; or &ldquo;along
with&rdquo; perhaps?
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<code>quot</code> returns the quotient, discards the remainder; <code>gcd</code> is
the built-in <i>greatest common divisor</i>; <code>signum</code> gives back <code>1</code> if
argument is greater than zero, <code>-1</code> if less than zero, zero if zero.
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In number theory, a <i>perfect number</i> is a positive integer that
is equal to the sum of its positive divisors, excluding the number
itself. For instance, \(6\) has divisors \(1\), \(2\) and \(3\) (excluding
itself), and \(1 + 2 + 3 = 6\;\), so \(6\) is a perfect number.
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
This is the crummier, brute-force version <br />
</p>
<table id="orgf7e8cd8" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Another attempt <br />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></div></div>

 --></div>
<div id="postamble" class="status">
<p class="date">Created: 2022-05-28 Sat 15:35</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
